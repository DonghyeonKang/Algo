<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <textarea>
        \n\n\n\n\n\n네트워크 워킹 그룹 T. 버너스 리의견을 요청합니다: 1945 MIT/LCS카테고리: 정보 R. 필딩 UC 어바인 H. 프리스틱 MIT/LCS 1996년 5월\n\n                하이퍼텍스트 전송 프로토콜 -- HTTP/1.0\n\n이 메모의 상태\n\n   이 메모는 인터넷 커뮤니티를 위한 정보를 제공합니다.  이 메모는 어떤 종류의 인터넷 표준을 지정하지 않습니다.  이 메모의 배포는 무제한입니다.\n\nIESG 참고:\n\n   IESG는 이 프로토콜에 대해 우려를 가지고 있으며, 이 문서가 비교적 빠른 시일 내에 표준 트랙 문서로 대체될 것으로 예상하고 있습니다.\n\n요약\n\n   하이퍼텍스트 전송 프로토콜(HTTP)은 분산된 협업 하이퍼미디어 정보 시스템에 필요한 가벼움과 속도를 갖춘 애플리케이션 수준의 프로토콜입니다. 요청 방법(명령어)의 확장을 통해 이름 서버 및 분산 객체 관리 시스템과 같은 많은 작업에 사용할 수 있는 일반적인 상태 비저장 객체 지향 프로토콜입니다. HTTP의 특징은 데이터 표현의 타이핑으로, 전송되는 데이터와 독립적으로 시스템을 구축할 수 있다는 점입니다.\n\n   HTTP는 1990년부터 월드와이드웹 글로벌 정보 이니셔티브에서 사용되어 왔습니다. 이 사양은 \"HTTP/1.0\"이라고 하는 프로토콜의 일반적인 사용법을 반영합니다.\n\n목차\n\n   1.  소개 ..............................................  4 1.1 목적 ..............................................  4 1.2 용어 ..........................................  4 1.3 전반적인 운영 ....................................  6 1.4 HTTP와 MIME ........................................  8 2.  표기법 및 일반 문법 ................  8 2.1 증강 BNF ........................................  8 2.2 기본 규칙 .......................................... 10 3.  프로토콜 매개변수 ....................................... 12\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n       3.1 HTTP 버전 ......................................... 12 3.2 유니폼 리소스 식별자 ......................... 14 3.2.1 일반 구문 ................................ 14 3.2.2 http URL ...................................... 15 3.3 날짜/시간 형식 .................................... 15 3.4 문자 집합 ....................................... 17 3.5 콘텐츠 코딩 ...................................... 18 3.6 미디어 유형 .......................................... 19 3.6.1 표준화 및 텍스트 기본값 ............ 19 3.6.2 멀티파트 유형 ............................... 20 3.7 제품 토큰 ....................................... 20 4.  HTTP 메시지 .............................................. 21 4.1 메시지 유형 ........................................ 21 4.2 메시지 헤더 ...................................... 22 4.3 일반 헤더 필드 ................................ 23 5.  요청 ................................................... 23 5.1 요청-라인 ......................................... 23 5.1.1 방법 ........................................ 24 5.1.2 요청-URI ................................... 24 5.2 요청 헤더 필드 ................................ 25 6.  응답 .................................................. 25 6.1 Status-Line .......................................... 26 6.1.1 상태 코드 및 이유 문구 ................. 26 6.2 응답 헤더 필드 ............................... 28 7.  엔티티 .................................................... 28 7.1 엔티티 헤더 필드 ................................. 29 7.2 엔티티 본문 .......................................... 29 7.2.1 유형 .......................................... 29 7.2.2 길이 ........................................ 30 8.  메서드 정의 ........................................ 30 8.1 GET .................................................. 31 8.2 HEAD ................................................. 31 8.3 POST ................................................. 31 9.  상태 코드 정의 ................................... 32 9.1 정보 1xx .................................... 32 9.2 성공 2xx ....................................... 32 9.3 리디렉션 3xx ...................................... 34 9.4 클라이언트 오류 4xx ..................................... 35 9.5 서버 오류 5xx ..................................... 37 10. 헤더 필드 정의 .................................. 37 10.1 허용 ............................................... 38 10.2 권한 부여 ....................................... 38 10.3 콘텐츠 인코딩 .................................... 39 10.4 콘텐츠 길이 ...................................... 39 10.5 Content-Type ........................................ 40 10.6 날짜 ................................................ 40 10.7 만료 ............................................. 41 10.8 출처 ................................................ 42\n\n\n\n버너스-리 등 정보 제공\fRFC 1945 HTTP/1.0 1996년 5월\n\n       10.9 If-Modified-Since ................................... 42 10.10 마지막 수정 ....................................... 43 10.11 위치 ............................................ 44 10.12 Pragma .............................................. 44 10.13 Referer ............................................. 44 10.14 서버 .............................................. 45 10.15 사용자-에이전트 .......................................... 46 10.16 WWW-Authenticate .................................... 46 11. 액세스 인증 ..................................... 47 11.1 기본 인증 체계 ......................... 48 12. 보안 고려 사항 ................................... 49 12.1 클라이언트 인증 ........................... 49 12.2 안전한 방법 ........................................ 49 12.3 서버 로그 정보 남용 ..................... 50 12.4 민감한 정보의 전송 ................... 50 12.5 파일 및 경로 이름을 기반으로 한 공격 ................ 51 13. 감사의 말 ........................................... 51 14. 참조 ................................................ 52 15. 저자 주소 ........................................ 54 부록 A.   인터넷 미디어 유형 메시지/http ................ 55 부록 B.   허용 애플리케이션 ........................... 55 부록 C.   MIME과의 관계 ............................ 56 C.1 표준 포맷으로의 변환 ......................... 56 C.2 날짜 형식의 변환 ........................... 57 C.3 콘텐츠 인코딩 도입 ..................... 57 C.4 콘텐츠 전송 인코딩 없음 ......................... 57 C.5 멀티파트 본문 부분의 HTTP 헤더 필드 ........... 57 부록 D.   추가 기능 ............................. 57 D.1 추가 요청 방법 ........................... 58 D.1.1 PUT ........................................... 58 D.1.2 DELETE ........................................ 58 D.1.3 링크 .......................................... 58 D.1.4 링크 해제 ........................................ 58 D.2 추가 헤더 필드 정의 .................. 58 D.2.1 Accept ........................................ 58 D.2.2 허용-문자세트 ................................ 59 D.2.3 Accept-Encoding ............................... 59 D.2.4 Accept-Language ............................... 59 D.2.5 콘텐츠-언어 .............................. 59 D.2.6 링크 .......................................... 59 D.2.7 MIME-Version .................................. 59 D.2.8 재시도-후 ................................... 60 D.2.9 제목 ......................................... 60 D.2.10 URI ........................................... 60\n\n\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n1.  소개\n\n1.1 목적\n\n   하이퍼텍스트 전송 프로토콜(HTTP)은 분산된 협업형 하이퍼미디어 정보 시스템에 필요한 가볍고 빠른 애플리케이션 수준의 프로토콜입니다. HTTP는 1990년부터 월드와이드웹 글로벌 정보 이니셔티브에서 사용되어 왔습니다. 이 사양은 \"HTTP/1.0\"이라고도 불리는 프로토콜의 일반적인 사용법을 반영합니다. 이 사양은 대부분의 HTTP/1.0 클라이언트와 서버에서 일관되게 구현되는 기능에 대해 설명합니다. 사양은 두 섹션으로 나뉩니다. 일반적으로 구현이 일관된 HTTP의 기능들은 이 문서의 본문에 설명되어 있습니다. 구현이 거의 없거나 일관되지 않은 기능은 부록 D에 나열되어 있습니다.\n\n   실제 정보 시스템에는 검색, 프런트엔드 업데이트, 주석 등 단순한 검색 이상의 기능이 필요합니다. HTTP는 요청의 목적을 나타내는 데 사용할 수 있는 개방형 메서드 집합을 허용합니다. 이는 메서드가 적용될 리소스를 표시하기 위해 위치(URL)[4] 또는 이름(URN)[16]으로 통일 리소스 식별자(URI)[2]가 제공하는 참조 규율을 기반으로 합니다. 메시지는 인터넷 메일[7] 및 다목적 인터넷 메일 확장(MIME)[5]에서 사용하는 것과 유사한 형식으로 전달됩니다.\n\n   HTTP는 사용자 에이전트와 프록시/게이트웨이 간의 통신을 위한 일반 프로토콜로도 사용되며, SMTP [12], NNTP [11], FTP [14], Gopher [1], WAIS [8] 등 다른 인터넷 프로토콜과도 통신할 수 있어 다양한 애플리케이션에서 제공되는 리소스에 대한 기본적인 하이퍼미디어 액세스를 허용하고 사용자 에이전트의 구현을 단순화해 줍니다.\n\n1.2 용어\n\n   이 명세서에서는 HTTP 통신의 참여자 및 객체가 수행하는 역할을 지칭하기 위해 여러 용어를 사용합니다.\n\n   연결\n\n       통신을 목적으로 두 애플리케이션 프로그램 사이에 설정된 전송 계층 가상 회로입니다.\n\n   메시지\n\n       섹션 4에 정의된 구문과 일치하는 구조화된 옥텟 시퀀스로 구성되며 연결을 통해 전송되는 HTTP 통신의 기본 단위입니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   요청\n\n       HTTP 요청 메시지(섹션 5에 정의됨).\n\n   응답\n\n       HTTP 응답 메시지(섹션 6에 정의됨).\n\n   resource\n\n       URI로 식별할 수 있는 네트워크 데이터 객체 또는 서비스(섹션 3.2).\n\n   엔티티\n\n       요청 또는 응답 메시지 내에 포함될 수 있는 데이터 리소스 또는 서비스 리소스의 응답의 특정 표현 또는 렌더링입니다. 엔티티는 엔티티 헤더 형식의 메타정보와 엔티티 본문 형식의 콘텐츠로 구성됩니다.\n\n   client\n\n       요청을 전송할 목적으로 연결을 설정하는 애플리케이션 프로그램입니다.\n\n   사용자 에이전트\n\n       요청을 시작하는 클라이언트입니다. 브라우저, 편집기, 스파이더(웹을 탐색하는 로봇) 또는 기타 최종 사용자 도구인 경우가 많습니다.\n\n   서버\n\n       응답을 전송하여 요청을 처리하기 위해 연결을 수락하는 애플리케이션 프로그램입니다.\n\n   원본 서버\n\n       특정 리소스가 상주하거나 생성될 서버입니다.\n\n   프록시\n\n       다른 클라이언트를 대신하여 요청을 할 목적으로 서버와 클라이언트 역할을 동시에 수행하는 중개 프로그램입니다.       요청은 내부적으로 처리되거나 가능한 경우 번역을 거쳐 다른 서버로 전달됩니다. 프록시는 요청 메시지를 해석하고 필요한 경우 요청 메시지를 다시 작성해야 합니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n       전달합니다. 프록시는 종종 네트워크 방화벽을 통한 클라이언트 측 포털로 사용되거나 사용자 에이전트가 구현하지 않은 프로토콜을 통해 요청을 처리하기 위한 도우미 애플리케이션으로 사용됩니다.\n\n   게이트웨이\n\n       다른 서버의 중개자 역할을 하는 서버입니다.       프록시와 달리 게이트웨이는 요청된 리소스의 원본 서버인 것처럼 요청을 수신하므로 요청 클라이언트는 자신이 게이트웨이와 통신하고 있다는 사실을 인지하지 못할 수 있습니다.       게이트웨이는 네트워크 방화벽을 통해 서버 측 포털로 사용되거나 비 HTTP 시스템에 저장된 리소스에 액세스하기 위한 프로토콜 변환기로 사용되는 경우가 많습니다.\n\n   터널\n\n       터널은 두 연결 사이의 블라인드 릴레이 역할을 하는 중개 프로그램입니다. 터널이 활성화되면 터널은 HTTP 요청에 의해 시작되었을지라도 HTTP 통신의 당사자로 간주되지 않습니다. 터널은 릴레이된 연결의 양쪽 끝이 닫히면 더 이상 존재하지 않습니다.       터널은 포털이 필요하고 중개자가 중계된 통신을 해석할 수 없거나 해석해서는 안 될 때 사용됩니다.\n\n   캐시\n\n       응답 메시지의 프로그램 로컬 저장소이자 메시지 저장, 검색 및 삭제를 제어하는 하위 시스템입니다. 캐시는 향후 동일한 요청에 대한 응답 시간 및 네트워크 대역폭 소비를 줄이기 위해 캐시 가능한 응답을 저장합니다. 모든 클라이언트 또는 서버에 캐시가 포함될 수 있지만, 서버가 터널 역할을 하는 동안에는 캐시를 사용할 수 없습니다.\n\n   특정 프로그램은 클라이언트와 서버 역할을 모두 수행할 수 있으며, 이러한 용어의 사용은 프로그램의 일반적인 기능보다는 특정 연결에 대해 프로그램이 수행하는 역할만을 의미합니다. 마찬가지로 모든 서버는 오리진 서버, 프록시, 게이트웨이 또는 터널 역할을 할 수 있으며 각 요청의 성격에 따라 동작을 전환할 수 있습니다.\n\n1.3 전체 운영\n\n   HTTP 프로토콜은 요청/응답 패러다임을 기반으로 합니다. 클라이언트는 서버와 연결을 설정하고 요청 방법, URI, 프로토콜 버전과 함께 요청 수정자, 클라이언트 정보, 가능한 본문 콘텐츠가 포함된 MIME 형식의 메시지를 서버에 보냅니다. 서버는\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   메시지의 프로토콜 버전과 성공 또는 오류 코드를 포함한 상태 줄과 서버 정보, 엔티티 메타정보, 가능한 본문 콘텐츠가 포함된 MIME 형식의 메시지가 이어집니다.\n\n   대부분의 HTTP 통신은 사용자 에이전트에 의해 시작되며 일부 원본 서버의 리소스에 적용하기 위한 요청으로 구성됩니다. 가장 간단한 경우에는 사용자 에이전트(UA)와 원본 서버(O) 간의 단일 연결(v)을 통해 이루어질 수 있습니다.\n\n          요청 체인 ------------------------; UA -------------------v------------------- O &lt;----------------------- 응답 체인\n\n   요청/응답 체인에 하나 이상의 중개자가 존재할 경우 더 복잡한 상황이 발생합니다. 중개자에는 프록시, 게이트웨이, 터널의 세 가지 일반적인 형태가 있습니다. 프록시는 전달 에이전트로, 절대 형식의 URI 요청을 수신하여 메시지의 전체 또는 일부를 재작성하고 재포맷된 요청을 URI로 식별된 서버로 전달합니다. 게이트웨이는 수신 에이전트로서 다른 서버 위에 있는 레이어 역할을 하며 필요한 경우 요청을 기본 서버의 프로토콜로 변환합니다. 터널은 메시지를 변경하지 않고 두 연결 사이의 중계 지점 역할을 하며, 중개자가 메시지 내용을 이해할 수 없는 경우에도 통신이 방화벽과 같은 중개자를 통과해야 할 때 터널을 사용합니다.\n\n          요청 체인 --------------------------------------; UA -----v----- A -----v----- B -----v----- C -----v----- O &lt;------------------------------------- 응답 체인\n\n   위 그림은 사용자 에이전트와 원본 서버 사이의 세 가지 중개자(A, B, C)를 보여줍니다. 전체 체인을 이동하는 요청 또는 응답 메시지는 4개의 개별 연결을 통과해야 합니다.   이 구분이 중요한 이유는 일부 HTTP 통신 옵션은 터널이 아닌 가장 가까운 이웃과의 연결에만 적용되거나, 체인의 엔드포인트에만 적용되거나, 체인의 모든 연결에 적용될 수 있기 때문입니다. 다이어그램은 선형적이지만 각 참여자는 여러 개의 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 이외의 많은 클라이언트로부터 요청을 받거나 A의 요청을 처리하는 동시에 C 이외의 서버로 요청을 전달할 수 있습니다.\n\n   터널 역할을 하지 않는 통신 당사자는 요청 처리를 위해 내부 캐시를 사용할 수 있습니다. 캐시의 효과는 체인의 참여자 중 한 명이 해당 요청에 해당하는 캐시된 응답을 가지고 있는 경우 요청/응답 체인이 단축된다는 것입니다. 다음은 B에\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   UA 또는 A에 의해 캐시되지 않은 요청에 대한 O의 이전 응답 사본(C를 통해)을 캐시합니다.\n\n          요청 체인 ----------&gt; UA -----v----- A -----v----- B - - - - - - C - - - - - - - O &lt;--------- 응답 체인\n\n   모든 응답이 캐싱 가능한 것은 아니며 일부 요청에는 캐시 동작에 특별한 요구 사항을 적용하는 수정자가 포함될 수 있습니다. 일부 HTTP/1.0 애플리케이션은 휴리스틱을 사용하여 \"캐싱 가능한\" 응답인지 아닌지를 설명하지만 이러한 규칙은 표준화되어 있지 않습니다.\n\n   인터넷에서 HTTP 통신은 일반적으로 TCP/IP 연결을 통해 이루어집니다. 기본 포트는 TCP 80[15]이지만 다른 포트를 사용할 수도 있습니다. 그렇다고 해서 인터넷이나 다른 네트워크의 다른 프로토콜 위에 HTTP가 구현되는 것을 배제하지는 않습니다. HTTP는 안정적인 전송을 전제로 할 뿐이며, 그러한 보장을 제공하는 모든 프로토콜을 사용할 수 있으며, HTTP/1.0 요청 및 응답 구조를 해당 프로토콜의 전송 데이터 단위로 매핑하는 것은 이 사양의 범위를 벗어납니다.\n\n   실험적인 애플리케이션을 제외하고, 현재 관행에서는 각 요청 전에 클라이언트가 연결을 설정하고 응답을 보낸 후 서버가 연결을 닫아야 합니다. 클라이언트와 서버 모두 사용자 작업, 자동 시간 초과 또는 프로그램 오류로 인해 어느 한쪽이 연결을 조기에 종료할 수 있음을 인지하고 예측 가능한 방식으로 연결을 종료해야 합니다. 어떤 경우든 한쪽 또는 양쪽 당사자가 연결을 종료하면 상태와 관계없이 항상 현재 요청이 종료됩니다.\n\n1.4 HTTP와 MIME\n\n   HTTP/1.0은 RFC 1521 [5]에 정의된 대로 MIME에 정의된 많은 구성을 사용합니다. 부록 C에서는 HTTP의 컨텍스트가 인터넷 메일에서 일반적으로 사용되는 것과 다른 인터넷 미디어 타입의 사용을 허용하는 방식과 그 차이에 대한 근거를 설명합니다.\n\n2.  표기법 및 일반 문법\n\n2.1 증강 BNF\n\n   이 문서에 명시된 모든 메커니즘은 산문과 RFC 822 [7]에서 사용하는 것과 유사한 증강 백커스-나우어 형식(BNF)으로 설명되어 있습니다. 구현자는 이 사양을 이해하려면 표기법에 익숙해야 합니다. 증강된 BNF에는 다음과 같은 구조가 포함됩니다:\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   이름 = 정의\n\n       규칙의 이름은 단순히 이름 자체(둘러싸는 \"&lt;\" 및 \"&gt;\" 없이)이며 정의와 동일한 문자 \"=\"로 구분됩니다. 공백은 두 줄 이상에 걸쳐 있는 규칙 정의를 나타낼 때 연속 줄의 들여쓰기가 사용된다는 점에서만 중요합니다. SP, LWS, HT, CRLF, DIGIT, ALPHA 등과 같은 특정 기본 규칙은 대문자로 되어 있습니다.       대괄호는 정의 내에서 규칙 이름을 쉽게 구분할 수 있는 경우에만 사용됩니다.\n\n   \"리터럴\"\n\n       따옴표는 리터럴 텍스트를 둘러싸고 있습니다. 달리 명시되지 않는 한 텍스트는 대소문자를 구분하지 않습니다.\n\n   규칙1 | 규칙2\n\n       막대(\"I\")로 구분된 요소는 대체 항목입니다(예: \"yes | no\"는 예 또는 아니오를 허용합니다).\n\n   (rule1 rule2)\n\n       괄호로 묶인 요소는 하나의 요소로 취급됩니다. 따라서 \"(elem (foo | bar) elem)\"은 토큰 시퀀스 \"elem foo elem\" 및 \"elem bar elem\"을 허용합니다.\n\n   *rule\n\n       요소 앞에 오는 문자 \"*\"는 반복을 나타냅니다. 전체 형식은 \"&lt;n&lt;*&lt;m&lt;element\"로, 최소 &lt;개, 최대 &lt;개까지 요소의 발생을 나타냅니다. 기본값은 0과 무한대이므로 \"*(엘리먼트)\"는 0을 포함한 모든 숫자를 허용하고 \"1*엘먼트\"는 최소 1개, \"1*2엘먼트\"는 1개 또는 2개의 엘리먼트를 허용합니다.\n\n   [규칙]\n\n       대괄호는 선택적 요소를 둘러싸며, \"[foo bar]\"는 \"*1(foo bar)\"와 동일합니다.\n\n   N 규칙\n\n       특정 반복: \"(요소)\"는 \"(요소)*(요소)\"와 동일합니다. 즉, (요소)의 정확히 &lt;n&lt;n&lt;발생 횟수입니다. 따라서 2DIGIT은 2자리 숫자이고 3ALPHA는 세 개의 알파벳 문자로 이루어진 문자열입니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   #rule\n\n       \"#\" 구조는 \"*\"와 유사하게 요소의 목록을 정의하기 위해 정의됩니다. 전체 형식은 \"#&n&lt; #&lt; 요소\"로, 하나 이상의 쉼표(\",\")와 선택적 선형 공백(LWS)으로 각각 구분된 최소 &n&lt;, 최대 &m&lt; 개의 요소를 나타냅니다. 따라서 일반적인 형태의 목록을 매우 쉽게 만들 수 있습니다. \"( *LWS 요소 *( *LWS \",\" *LWS 요소 ))\"와 같은 규칙은 \"1#element\"로 표시할 수 있습니다. 이 구문이 사용되는 모든 곳에서 널 요소는 허용되지만 존재하는 요소의 수에 기여하지 않습니다.       즉, \"(요소), , (요소)\"는 허용되지만 두 개의 요소로만 계산됩니다. 따라서 요소가 하나 이상 필요한 경우 null이 아닌 요소가 하나 이상 있어야 합니다. 기본값은 0과 무한대이므로 \"#(엘리먼트)\"는 0을 포함한 모든 숫자를 허용하고 \"1#엘리먼트\"는 최소 1개, \"1#2엘리먼트\"는 하나 또는 두 개를 허용합니다.\n\n   댓글\n\n       세미콜론은 규칙 텍스트의 오른쪽에서 일정 거리를 두고 줄 끝에서 계속되는 주석을 시작합니다. 이것은 사양과 병행하여 유용한 메모를 포함하는 간단한 방법입니다.\n\n   암시 *LWS\n\n       이 사양에서 설명하는 문법은 단어 기반입니다.       달리 명시된 경우를 제외하고, 인접한 두 단어(토큰 또는 따옴표로 묶인 문자열) 사이, 인접한 토큰과 구분자(tspecial) 사이에 필드의 해석을 변경하지 않고 선형 공백(LWS)을 포함할 수 있습니다. 그렇지 않으면 하나의 토큰으로 해석되므로 두 토큰 사이에 적어도 하나의 구분 기호(tspecial)가 존재해야 합니다. 그러나 공통 형식을 벗어나는 것을 허용하지 않는 구현이 일부 존재하므로 애플리케이션은 HTTP 구성을 생성할 때 \"공통 형식\"을 따라야 합니다.\n\n2.2 기본 규칙\n\n   이 명세서 전체에서 기본 구문 분석 구문을 설명하기 위해 다음 규칙이 사용됩니다. US-ASCII 코딩 문자 집합은 [17]에 정의되어 있습니다.\n\n       OCTET = 임의의 8비트 데이터 시퀀스 &gt; CHAR = 임의의 US-ASCII 문자(옥텟 0~127)&gt; UPALPHA = 임의의 US-ASCII 대문자 \"A\"...\"Z\"&gt; LOALPHA = 임의의 US-ASCII 소문자 \"a\"...\"z\"&gt;\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n       알파 = 업팔파 | 로알파 숫자 = &lt;임의의 US-ASCII 숫자 \"0\".\"9\"&gt; CTL = 모든 US-ASCII 제어 문자 (0 - 31 옥텟) 및 DEL (127)&gt; CR = US-ASCII CR, 캐리지 리턴 (13)&gt; LF = &lt;US-ASCII LF, 줄 바꿈 (10)&gt; SP = &lt;US-ASCII SP, 공백 (32)&gt; HT = &lt;US-ASCII HT, 가로 탭 (9)&gt; &lt;\"&gt; = &lt;US-ASCII 큰따옴표 (34)&gt;\n\n   HTTP/1.0은 엔티티-바디를 제외한 모든 프로토콜 요소의 줄 끝 마커로 옥텟 시퀀스 CR LF를 정의합니다(허용되는 애플리케이션에 대해서는 부록 B 참조). 엔티티-바디 내의 줄 끝 마커는 섹션 3.6에 설명된 대로 관련 미디어 유형에 의해 정의됩니다.\n\n       CRLF = CR LF\n\n   각 연속 줄이 공백 또는 가로 탭으로 시작하는 경우 HTTP/1.0 헤더는 여러 줄로 접힐 수 있습니다. 접기를 포함한 모든 선형 공백은 SP와 동일한 의미를 갖습니다.\n\n       LWS = [CRLF] 1*( SP | HT )\n\n   그러나 일부 애플리케이션에서는 헤더 줄 접기가 예상되지 않으므로 HTTP/1.0 애플리케이션에서 생성해서는 안 됩니다.\n\n   TEXT 규칙은 메시지 파서가 해석하지 않으려는 설명적 필드 콘텐츠 및 값에만 사용됩니다. TEXT의 단어에는 US-ASCII 이외의 문자 집합의 옥텟이 포함될 수 있습니다.\n\n       TEXT = &lt;CTL을 제외한 모든 옥텟(LWS 포함)&gt;\n\n   US-ASCII 문자 집합 이외의 옥텟을 포함하는 헤더 필드 TEXT의 수신자는 해당 문자가 ISO-8859-1 문자를 나타내는 것으로 간주할 수 있습니다.\n\n   16진수 문자는 여러 프로토콜 요소에 사용됩니다.\n\n       HEX = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | DIGIT\n\n   많은 HTTP/1.0 헤더 필드 값은 LWS 또는 특수 문자로 구분된 단어로 구성됩니다. 이러한 특수 문자는 매개변수 값 내에서 사용하려면 따옴표로 묶인 문자열 안에 있어야 합니다.\n\n       단어 = 토큰 | 따옴표로 묶은 문자열\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n       토큰 = 1*&lt;CTL 또는 tspecial을 제외한 모든 문자&gt;\n\n       tspecials = \"(\" | \")\" | \"&lt;\" | \"&gt;\" | \"@\" | \",\" | \";\" | \":\" | \"\\\" | &lt;\"&gt; | \"/\" | \"[\" | \"]\" | \"?\" | \"=\" | \"{\" | \"}\" | SP | HT\n\n   댓글 텍스트를 괄호로 둘러싸면 일부 HTTP 헤더 필드에 댓글이 포함될 수 있습니다. 댓글은 필드 값 정의의 일부로 \"댓글\"이 포함된 필드에서만 허용됩니다.   다른 모든 필드에서는 괄호가 필드 값의 일부로 간주됩니다.\n\n       comment = \"(\" *( ctext | comment ) \")\" ctext = &lt; \"(\" 및 \")\"를 제외한 모든 텍스트;\n\n   텍스트 문자열이 큰따옴표로 따옴표로 묶인 경우 단일 단어로 구문 분석됩니다.\n\n       따옴표로 묶은 문자열 = ( &lt;\"&gt; *(qdtext) &lt;\"&gt; )\n\n       qdtext = &lt;&lt;\"&gt; 및 CTL을 제외한 모든 문자(LWS 포함)&gt;\n\n   백슬래시(\"\\\") 문자를 사용한 단일 문자 인용은 HTTP/1.0에서 허용되지 않습니다.\n\n3.  프로토콜 매개변수\n\n3.1 HTTP 버전\n\n   HTTP는 프로토콜의 버전을 표시하기 위해 \"메이저\" 및 \"마이너\" 번호 체계를 사용합니다. 프로토콜 버전 관리 정책은 발신자가 해당 통신을 통해 얻은 기능보다는 메시지의 형식과 추가 HTTP 통신을 이해하기 위한 용량을 표시할 수 있도록 하기 위한 것입니다. 통신 동작에 영향을 미치지 않거나 확장 가능한 필드 값에만 추가되는 메시지 구성 요소의 추가에 대해서는 버전 번호가 변경되지 않습니다.   프로토콜 변경으로 인해 일반적인 메시지 구문 분석 알고리즘은 변경되지 않지만 메시지 의미론에 추가되고 발신자의 추가 기능을 암시할 수 있는 기능이 추가되는 경우 <부> 번호가 증가합니다. 프로토콜 내에서 메시지 형식이 변경되면 '주요' 번호가 증가합니다.\n\n   HTTP 메시지의 버전은 메시지 첫 줄의 HTTP-Version 필드에 표시됩니다. 프로토콜 버전이 지정되지 않은 경우 수신자는 메시지의 버전이\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   간단한 HTTP/0.9 형식.\n\n       HTTP-Version = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT\n\n   주 숫자와 부 숫자는 별도의 정수로 취급해야 하며 각각 한 자리보다 높게 증가될 수 있다는 점에 유의하세요.   따라서 HTTP/2.4는 HTTP/2.13보다 하위 버전이며, 이는 다시 HTTP/12.3보다 하위 버전입니다. 수신자는 선행 0을 무시해야 하며 발신자는 절대로 선행 0을 생성해서는 안 됩니다.\n\n   이 문서는 HTTP 프로토콜의 0.9 버전과 1.0 버전을 모두 정의합니다. 이 규격에 정의된 대로 전체 요청 또는 전체 응답 메시지를 보내는 애플리케이션은 반드시 \"HTTP/1.0\" 버전의 HTTP를 포함해야 합니다.\n\n   HTTP/1.0 서버는 반드시:\n\n      o HTTP/0.9 및 HTTP/1.0 요청에 대한 요청-라인 형식을 인식해야 합니다;\n\n      o HTTP/0.9 또는 HTTP/1.0 형식의 유효한 요청을 이해해야 합니다;\n\n      o 클라이언트가 사용하는 프로토콜 버전과 동일한 메시지로 적절하게 응답합니다.\n\n   HTTP/1.0 클라이언트는 반드시:\n\n      o HTTP/1.0 응답에 대한 상태 표시줄 형식을 인식해야 합니다;\n\n      o HTTP/0.9 또는 HTTP/1.0 형식의 유효한 응답을 이해할 수 있어야 합니다.\n\n   프록시 및 게이트웨이 애플리케이션은 애플리케이션의 기본 HTTP 버전과 다른 형식으로 수신된 요청을 전달할 때 주의를 기울여야 합니다. 프로토콜 버전은 발신자의 프로토콜 기능을 나타내므로 프록시/게이트웨이는 버전 표시기가 기본 버전보다 큰 메시지를 보내서는 안 되며, 더 높은 버전의 요청이 수신되면 요청 버전을 다운그레이드하거나 오류로 응답해야 합니다. 애플리케이션의 기본 형식보다 낮은 버전의 요청은 전달되기 전에 업그레이드될 수 있으며, 해당 요청에 대한 프록시/게이트웨이의 응답은 위에 나열된 서버 요구 사항을 따라야 합니다.\n\n\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n3.2 유니폼 리소스 식별자\n\n   URI는 다양한 이름으로 알려져 있습니다: WWW 주소, 범용 문서 식별자, 범용 리소스 식별자[2], 그리고 마지막으로 URL(Uniform Resource Locator)[4]과 이름(URN)[16]의 조합으로 알려져 있습니다. HTTP에 관한 한, 유니폼 리소스 식별자는 이름, 위치 또는 기타 특성을 통해 네트워크 리소스를 식별하는 단순한 형식의 문자열입니다.\n\n3.2.1 일반 구문\n\n   HTTP의 URI는 사용 컨텍스트에 따라 절대 형식으로 표현하거나 알려진 기본 URI[9]에 상대적으로 표현할 수 있습니다. 두 형식은 절대 URI가 항상 스키마 이름 뒤에 콜론으로 시작한다는 사실로 구분됩니다.\n\n       URI = ( 절대URI | 상대URI ) [ \"#\" 조각 ]입니다.\n\n       절대URI = 스키마 \":\" *( uchar | reserved )\n\n       상대URI = net_path | abs_path | rel_path\n\n       net_path = \"//\" net_loc [ abs_path ] abs_path = \"/\" rel_path rel_path = [ 경로 ] [ \";\" params ] [ \"?\" 쿼리 ]\n\n       경로 = fsegment *( \"/\" 세그먼트 ) fsegment = 1*pchar 세그먼트 = *pchar\n\n       params = param *( \";\" param ) param = *( pchar | \"/\" )\n\n       scheme = 1*( 알파 | 숫자 | \"+\" | \"-\" | \".\" ) net_loc = *( pchar | \";\" | \"?\" ) query = *( uchar | 예약 ) fragment = *( uchar | 예약 )\n\n       pchar = uchar | \":\" | \"@\" | \"&amp;\" | \"=\" | \"+\" uchar = 예약되지 않음 | 이스케이프 예약되지 않음 = 알파 | 숫자 | 안전 | 추가 | 국가\n\n       이스케이프 = \"%\" HEX HEX 예약됨 = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&amp;\" | \"=\" | \"+\" extra = \"!\" | \"*\" | \"'\" | \"(\" | \")\" | \",\" safe = \"$\" | \"-\" | \"_\" | \".\" unsafe = CTL | SP | \"#\" | \"%\" | \"&lt;\"&lt;\" | \"&gt;\" national = &lt;알파, 숫자를 제외한 모든 옥텟,\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n                        예약, 추가, 안전, 안전하지 않음;\n\n   URL 구문과 의미에 대한 자세한 내용은 RFC 1738 [4] 및 RFC 1808 [9]을 참조하세요. HTTP 서버는 주소의 rel_path 부분을 나타내는 데 허용되는 예약되지 않은 문자 집합에 제한이 없으며 HTTP 프록시는 RFC 1738에 정의되지 않은 URI에 대한 요청을 받을 수 있으므로 위의 BNF에는 RFC 1738에 지정된 유효한 URL에 허용되지 않는 국가 문자가 포함되어 있습니다.\n\n3.2.2 HTTP URL\n\n   \"http\" 스키마는 HTTP 프로토콜을 통해 네트워크 리소스를 찾는 데 사용됩니다. 이 섹션에서는 http URL에 대한 스키마별 구문과 의미를 정의합니다.\n\n       http_URL = \"http:\" \"//\" 호스트 [ \":\" 포트 ] [ abs_path ]입니다.\n\n       host = &lt;RFC 1123의 섹션 2.1에 정의된 합법적인 인터넷 호스트 도메인 이름 또는 IP 주소(점으로 구분된 10진수 형식)입니다;\n\n       port = *DIGIT\n\n   포트가 비어 있거나 지정되지 않은 경우 포트 80으로 가정합니다. 의미는 식별된 리소스가 해당 호스트의 해당 포트에서 TCP 연결을 수신 대기 중인 서버에 있으며 리소스에 대한 Request-URI는 abs_path라는 것입니다. abs_path가 URL에 없는 경우 요청-URI로 사용할 때는 \"/\"로 지정해야 합니다(섹션 5.1.2).\n\n      참고: HTTP 프로토콜은 전송 계층 프로토콜과 독립적이지만 http URL은 TCP 위치로만 리소스를 식별하므로 TCP가 아닌 리소스는 다른 URI 체계로 식별해야 합니다.\n\n   \"http\" URL의 표준 형식은 호스트의 UPALPHA 문자를 해당 LOALPHA 문자로 변환하고(호스트명은 대소문자를 구분하지 않음), 포트가 80인 경우 [ \":\" 포트]를 생략하고 빈 abs_path를 \"/\"로 대체하여 얻을 수 있습니다.\n\n3.3 날짜/시간 형식\n\n   HTTP/1.0 애플리케이션은 지금까지 날짜/시간 스탬프 표현을 위해 세 가지 형식을 허용해 왔습니다:\n\n       1994년 11월 6일 08:49:37 GMT; RFC 822, RFC 1123에 의해 업데이트된 94년 11월 6일 일요일 08:49:37 GMT; RFC 850, RFC 1036에 의해 폐지된 1994년 11월 6일 일요일 08:49:37; ANSI C의 asctime() 형식.\n\n\n\n버너스-리 외 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   첫 번째 형식은 인터넷 표준으로 선호되며 RFC 1123[6](RFC 822[7]에 대한 업데이트)에 정의된 형식의 고정 길이 하위 집합을 나타냅니다. 두 번째 형식은 일반적으로 사용되지만 더 이상 사용되지 않는 RFC 850[10] 날짜 형식을 기반으로 하며 4자리 연도가 없습니다.   날짜 값을 구문 분석하는 HTTP/1.0 클라이언트와 서버는 세 가지 형식을 모두 허용해야 하지만 세 번째(asctime) 형식은 절대 생성해서는 안 됩니다.\n\n      참고: 날짜 값의 수신자는 프록시/게이트웨이를 통해 메시지를 SMTP 또는 NNTP로 검색하거나 게시할 때와 같이 HTTP가 아닌 애플리케이션에서 생성되었을 수 있는 날짜 값을 강력하게 받아들이는 것이 좋습니다.\n\n   모든 HTTP/1.0 날짜/시간 스탬프는 예외 없이 그리니치 표준시(GMT)로도 알려진 세계시(UT)로 표시되어야 합니다.   이는 처음 두 형식에서 시간대의 세 글자 약어로 \"GMT\"가 포함됨으로써 표시되며, asctime 형식을 읽을 때 이를 가정해야 합니다.\n\n       HTTP-date = rfc1123-date | rfc850-date | asctime-date\n\n       rfc1123-date = wkday \",\" SP date1 SP 시간 SP \"GMT\" rfc850-date = weekday \",\" SP date2 SP 시간 SP \"GMT\" asctime-date = wkday SP date3 SP 시간 SP 4DIGIT\n\n       date1 = 2DIGIT SP 월 SP 4DIGIT ; 일 월 년(예: 1982년 6월 2일) date2 = 2DIGIT \"-\" 월 \"-\" 2DIGIT ; 일 월 년(예: 02-Jun-82) date3 = 월 SP ( 2DIGIT | ( SP 1DIGIT )) ; 월 일(예: 6월 2일)\n\n       time = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT ; 00:00:00 - 23:59:59\n\n       wkday = \"Mon\" | \"화\" | \"수\" | \"목\" | \"금\" | \"토\" | \"Sun\"\n\n       weekday = \"월요일\" | \"화요일\" | \"수요일\" | \"목요일\" | \"금요일\" | \"토요일\" | \"일요일\"\n\n       월 = \"1월\" | \"2월\" | \"3월\" | \"Apr\"                      | \"5월\" | \"6월\" | \"7월\" | \"8월\" | \"9월\" | \"10월\" | \"11월\" | \"Dec\"\n\n       참고: 날짜/시간 스탬프 형식에 대한 HTTP 요구사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 클라이언트와 서버는 사용자에 대해 이러한 형식을 사용할 필요가 없습니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n       프레젠테이션, 요청 로깅 등\n\n3.4 문자 집합\n\n   HTTP는 MIME에 대해 설명한 것과 동일한 \"문자 집합\"이라는 용어의 정의를 사용합니다:\n\n      이 문서에서 \"문자 집합\"이라는 용어는 하나 이상의 테이블을 사용하여 일련의 옥텟을 문자 시퀀스로 변환하는 방법을 지칭하는 데 사용됩니다. 주어진 문자 세트에서 모든 문자를 사용할 수 있는 것은 아니며 문자 세트가 특정 문자를 표현하기 위해 하나 이상의 옥텟 시퀀스를 제공할 수 있으므로 무조건 다른 방향으로 변환할 필요는 없습니다. 이 정의는 US-ASCII와 같은 단순한 단일 테이블 매핑부터 ISO 2022의 기술을 사용하는 복잡한 테이블 전환 방법까지 다양한 종류의 문자 인코딩을 허용하기 위한 것입니다. 단, MIME 문자 집합 이름과 관련된 정의에는 옥텟에서 문자로 수행되는 매핑이 완전히 명시되어 있어야 합니다. 특히 정확한 매핑을 결정하기 위해 외부 프로파일링 정보를 사용하는 것은 허용되지 않습니다.\n\n      참고: 이러한 \"문자 집합\"이라는 용어의 사용은 \"문자 인코딩\"이라고 더 일반적으로 불립니다. 그러나 HTTP와 MIME은 동일한 레지스트리를 공유하므로 용어 또한 공유하는 것이 중요합니다.\n\n   HTTP 문자 집합은 대소문자를 구분하지 않는 토큰으로 식별됩니다. 전체 토큰 세트는 IANA 문자 집합 레지스트리[15]에 정의되어 있습니다. 그러나 이 레지스트리는 각 문자 집합에 대해 일관된 단일 토큰을 정의하지 않기 때문에 여기서는 HTTP 엔티티에 가장 많이 사용되는 문자 집합에 대해 선호하는 이름을 정의합니다. 이러한 문자 세트에는 RFC 1521[5]에 등록된 문자 세트, 즉 US-ASCII[17] 및 ISO-8859[18] 문자 세트와 MIME 문자 세트 매개변수 내에서 사용하도록 특별히 권장되는 기타 이름이 포함됩니다.\n\n     charset = \"US-ASCII\" | \"ISO-8859-1\" | \"ISO-8859-2\" | \"ISO-8859-3\" | \"ISO-8859-4\" | \"ISO-8859-5\" | \"ISO-8859-6\" | \"ISO-8859-7\" | \"ISO-8859-8\" | \"ISO-8859-9\" | \"ISO-2022-JP\" | \"ISO-2022-JP-2\" | \"ISO-2022-KR\"             | \"UNICODE-1-1\" | \"UNICODE-1-1-UTF-7\" | \"UNICODE-1-1-UTF-8\" | 토큰\n\n   HTTP에서는 임의의 토큰을 문자 집합 값으로 사용할 수 있지만, IANA 문자 집합 레지스트리[15] 내에 사전 정의된 값을 가진 토큰은 반드시 정의된 문자 집합을 나타내야 합니다.\n\n\n\nBerners-Lee 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   에 의해 정의되었습니다. 애플리케이션은 문자 집합 사용을 IANA 레지스트리에 정의된 문자 집합으로 제한해야 합니다.\n\n   엔티티 본문의 문자 집합은 해당 본문 내에서 사용되는 문자 코드의 최하위 공통 분모로 레이블을 지정해야 하지만, US-ASCII 또는 ISO-8859-1 레이블보다 선호되는 레이블은 없습니다.\n\n3.5 콘텐츠 코딩\n\n   콘텐츠 코딩 값은 리소스에 적용된 인코딩 변환을 나타내는 데 사용됩니다. 콘텐츠 코딩은 주로 기본 미디어 유형의 신원을 잃지 않고 문서를 압축하거나 암호화할 수 있도록 하는 데 사용됩니다. 일반적으로 리소스는 이 인코딩으로 저장되며 렌더링 또는 이와 유사한 사용 전에만 디코딩됩니다.\n\n       content-coding = \"x-gzip\" | \"x-compress\" | 토큰\n\n       참고: 향후 호환성을 위해 HTTP/1.0 애플리케이션은 \"gzip\" 및 \"compress\"를 각각 \"x-gzip\" 및 \"x-compress\"와 동등한 것으로 간주해야 합니다.\n\n   모든 콘텐츠 코딩 값은 대소문자를 구분하지 않습니다. HTTP/1.0은 Content-Encoding(섹션 10.3) 헤더 필드에 콘텐츠-코딩 값을 사용합니다. 이 값은 콘텐츠 인코딩을 설명하지만, 더 중요한 것은 인코딩을 제거하는 데 필요한 디코딩 메커니즘을 나타낸다는 점입니다. 하나의 프로그램이 여러 콘텐츠 코딩 형식을 디코딩할 수 있다는 점에 유의하세요. 이 사양에는 두 가지 값이 정의되어 있습니다:\n\n   x-gzip 장 루프 게일리가 개발한 파일 압축 프로그램 \"gzip\"(GNU zip)에서 생성하는 인코딩 형식입니다. 이 형식은 일반적으로 32비트 CRC를 사용하는 렘펠-지브 코딩(LZ77)입니다.\n\n   x-compress 파일 압축 프로그램 \"compress\"에서 생성하는 인코딩 형식입니다. 이 형식은 적응형 렘펠-지브-웰치 코딩(LZW)입니다.\n\n       참고: 인코딩 형식을 식별하기 위해 프로그램 이름을 사용하는 것은 바람직하지 않으며 향후 인코딩에는 사용하지 않는 것이 좋습니다. 여기서 이러한 이름을 사용하는 것은 좋은 디자인이 아니라 과거의 관행을 대표하는 것입니다.\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n3.6 미디어 유형\n\n   HTTP는 개방적이고 확장 가능한 데이터 타입을 제공하기 위해 Content-Type 헤더 필드(섹션 10.5)에서 인터넷 미디어 타입[13]을 사용합니다.\n\n       미디어 타입 = 타입 \"/\" 서브타입 *( \";\" 매개변수 ) 타입 = 토큰 서브타입 = 토큰\n\n   매개변수는 속성/값 쌍의 형태로 유형/서브타입 뒤에 올 수 있습니다.\n\n       매개변수 = 속성 \"=\" 값 속성 = 토큰 값 = 토큰 | 따옴표로 묶은 문자열\n\n   유형, 하위 유형 및 매개변수 속성 이름은 대소문자를 구분하지 않습니다. 매개변수 값은 매개변수 이름의 의미에 따라 대소문자를 구분할 수도 있고 구분하지 않을 수도 있습니다. 유형과 하위 유형 사이 또는 속성과 해당 값 사이에 LWS를 생성해서는 안 됩니다. 인식할 수 없는 파라미터가 포함된 미디어 유형을 수신하면 사용자 에이전트는 인식할 수 없는 파라미터와 해당 값이 없는 것처럼 미디어 유형을 처리해야 합니다.\n\n   일부 구형 HTTP 애플리케이션은 미디어 유형 매개변수를 인식하지 못합니다.   HTTP/1.0 애플리케이션은 메시지 내용을 정의하는 데 필요한 경우에만 미디어 타입 파라미터를 사용해야 합니다.\n\n   미디어 유형 값은 인터넷 할당 번호 기관(IANA [15])에 등록됩니다. 미디어 유형 등록 절차는 RFC 1590 [13]에 설명되어 있습니다. 등록되지 않은 미디어 유형을 사용하는 것은 권장하지 않습니다.\n\n3.6.1 표준화 및 텍스트 기본값\n\n   인터넷 미디어 유형은 표준 양식으로 등록됩니다. 일반적으로 HTTP를 통해 전송되는 엔티티-바디는 전송 전에 적절한 표준 형식으로 표현되어야 합니다. 본문이 콘텐츠 인코딩으로 인코딩된 경우 기본 데이터는 인코딩되기 전에 표준 형식이어야 합니다.\n\n   \"텍스트\" 유형의 미디어 하위 유형은 표준 형식일 때 텍스트 줄 바꿈으로 CRLF를 사용합니다. 그러나 HTTP는 엔티티 본문 내에서 일관되게 사용되는 경우 일반 CR 또는 LF만으로 줄 바꿈을 나타내는 텍스트 미디어의 전송을 허용합니다. HTTP 애플리케이션은 HTTP를 통해 수신된 텍스트 미디어에서 줄 바꿈을 나타내는 것으로 CRLF, 베어 CR 및 베어 LF를 허용해야 합니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   또한 일부 멀티바이트 문자 집합의 경우처럼 텍스트 미디어가 CR과 LF에 각각 13과 10의 옥텟을 사용하지 않는 문자 집합으로 표현되는 경우, HTTP는 해당 문자 집합에 정의된 어떤 옥텟 시퀀스를 사용해도 줄 바꿈에 해당하는 CR과 LF를 표현할 수 있습니다. 줄 바꿈에 대한 이러한 유연성은 엔티티 본문의 텍스트 미디어에만 적용되며, 헤더 필드 및 멀티파트 경계와 같은 HTTP 제어 구조 내에서 CR 또는 LF를 CRLF로 대체해서는 안 됩니다.\n\n   \"charset\" 매개변수는 일부 미디어 유형과 함께 데이터의 문자 집합을 정의하는 데 사용됩니다(섹션 3.4). 발신자가 명시적인 문자셋 매개변수를 제공하지 않은 경우, \"텍스트\" 유형의 미디어 하위 유형은 HTTP를 통해 수신될 때 기본 문자셋 값인 \"ISO-8859-1\"을 갖도록 정의됩니다. \"ISO-8859-1\" 또는 그 하위 집합이 아닌 문자 집합의 데이터는 수신자가 일관되게 해석할 수 있도록 적절한 문자 집합 값으로 레이블을 지정해야 합니다.\n\n      참고: 현재 많은 HTTP 서버는 적절한 레이블 없이 \"ISO-8859-1\" 이외의 문자셋을 사용하여 데이터를 제공합니다. 이러한 상황은 상호 운용성을 저하시키므로 권장되지 않습니다. 이를 보완하기 위해 일부 HTTP 사용자 에이전트는 문자셋 매개변수가 지정되지 않은 경우 사용자가 미디어 유형 문자 집합의 기본 해석을 변경할 수 있는 구성 옵션을 제공합니다.\n\n3.6.2 멀티파트 유형\n\n   MIME은 단일 메시지의 엔티티-바디 내에 여러 엔티티를 캡슐화한 여러 \"멀티파트\" 타입을 제공합니다. IANA[15]에 등록된 멀티파트 타입은 HTTP/1.0에서 특별한 의미가 없지만, 사용자 에이전트는 각 본문 부분의 목적을 올바르게 해석하기 위해 각 타입을 이해해야 할 수 있습니다. HTTP 사용자 에이전트는 멀티파트 타입을 수신할 때 MIME 사용자 에이전트와 동일하거나 유사한 동작을 따라야 합니다. HTTP 서버는 모든 HTTP 클라이언트가 멀티파트 타입을 처리할 준비가 되어 있다고 가정해서는 안 됩니다.\n\n   모든 멀티파트 타입은 공통 구문을 공유하며 미디어 타입 값의 일부로 경계 파라미터를 포함해야 합니다. 메시지 본문은 그 자체로 프로토콜 요소이므로 본문 부분 사이의 줄 바꿈을 표현할 때는 CRLF만 사용해야 합니다. 멀티파트 본문 부분에는 해당 부분의 의미에 중요한 HTTP 헤더 필드가 포함될 수 있습니다.\n\n3.7 제품 토큰\n\n   제품 토큰은 통신하는 애플리케이션이 슬래시 및 버전 지정자(선택 사항)와 함께 간단한 제품 토큰을 통해 자신을 식별할 수 있도록 하는 데 사용됩니다. 제품 토큰을 사용하는 대부분의 필드에서는 애플리케이션의 중요한 부분을 구성하는 하위 제품도 다음을 수행할 수 있습니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   를 공백으로 구분하여 나열합니다. 관례에 따라 애플리케이션을 식별하는 데 중요한 순서대로 나열됩니다.\n\n       제품 = 토큰 [\"/\" 제품-버전] 제품-버전 = 토큰\n\n   예시\n\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n\n       Server: Apache/0.8.4\n\n   제품 토큰은 짧고 간결해야 하며, 광고나 기타 필수적이지 않은 정보에 사용하는 것은 명시적으로 금지되어 있습니다. 제품 버전에 토큰 문자가 표시될 수 있지만 이 토큰은 버전 식별자로만 사용해야 합니다(즉, 동일한 제품의 후속 버전은 제품 값의 제품 버전 부분만 달라져야 합니다).\n\n4.  HTTP 메시지\n\n4.1 메시지 유형\n\n   HTTP 메시지는 클라이언트가 서버에 보내는 요청과 서버가 클라이언트에 보내는 응답으로 구성됩니다.\n\n       HTTP-message = 단순 요청 ; HTTP/0.9 메시지 | 단순 응답 | 전체 요청 ; HTTP/1.0 메시지 | 전체 응답\n\n   전체 요청과 전체 응답은 엔티티 전송에 RFC 822[7]의 일반 메시지 형식을 사용합니다. 두 메시지 모두 선택적 헤더 필드(\"헤더\"라고도 함)와 엔티티 본문을 포함할 수 있습니다. 엔티티 본문은 헤더와 널 줄(즉, CRLF 앞에 아무것도 없는 줄)로 구분됩니다.\n\n       전체 요청 = 요청-줄 ; 섹션 5.1 *( 일반-헤더 ; 섹션 4.3 | 요청-헤더 ; 섹션 5.2 | 엔티티-헤더 ) ; 섹션 7.1 CRLF [ 엔티티-바디 ] ; 섹션 7.2\n\n       전체 응답 = 상태-라인 ; 섹션 6.1 *( 일반-헤더 ; 섹션 4.3 | 응답-헤더 ; 섹션 6.2\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n                         | 엔티티-헤더 ) ; 섹션 7.1 CRLF [ 엔티티-바디 ] ; 섹션 7.2\n\n   단순 요청 및 단순 응답은 헤더 정보를 사용할 수 없으며 단일 요청 메서드(GET)로 제한됩니다.\n\n       단순 요청 = \"GET\" SP 요청-URI CRLF\n\n       단순-응답 = [ 엔티티-본문 ]입니다.\n\n   Simple-Request 형식은 서버가 반환된 엔티티의 미디어 유형을 식별할 수 없으므로 사용하지 않는 것이 좋습니다.\n\n4.2 메시지 헤더\n\n   일반-헤더(섹션 4.3), 요청-헤더(섹션 5.2), 응답-헤더(섹션 6.2), 엔티티-헤더(섹션 7.1) 필드를 포함하는 HTTP 헤더 필드는 RFC 822 [7]의 섹션 3.1에 제시된 것과 동일한 일반 형식을 따릅니다. 각 헤더 필드는 이름 바로 뒤에 콜론(\":\"), 공백(SP) 문자 하나, 필드 값으로 구성됩니다. 필드 이름은 대소문자를 구분하지 않습니다.   헤더 필드는 각 추가 줄 앞에 하나 이상의 SP 또는 HT를 추가하여 여러 줄에 걸쳐 확장할 수 있지만 권장되지는 않습니다.\n\n       HTTP-header = 필드 이름 \":\" [ 필드 값 ] CRLF\n\n       필드 이름 = 토큰 필드 값 = *( 필드 콘텐츠 | LWS )\n\n       field-content = &lt;필드 값을 구성하고 *TEXT 또는 토큰, tspecials 및 따옴표로 묶은 문자열의 조합으로 구성된 OCTET &gt;\n\n   헤더 필드가 수신되는 순서는 중요하지 않습니다.   그러나 일반-헤더 필드를 먼저 보내고 요청-헤더 또는 응답-헤더 필드를 엔티티-헤더 필드보다 먼저 보내는 것이 '좋은 관행'입니다.\n\n   동일한 필드명을 가진 여러 개의 HTTP 헤더 필드는 해당 헤더 필드의 전체 필드값이 쉼표로 구분된 목록[즉, #(값)]으로 정의된 경우에만 메시지 내에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고도 쉼표로 구분된 각 후속 필드 값을 첫 번째 필드 값에 추가하여 여러 헤더 필드를 하나의 \"필드 이름: 필드 값\" 쌍으로 결합할 수 있어야 합니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n4.3 일반 헤더 필드\n\n   요청 및 응답 메시지 모두에 일반적으로 적용 가능하지만 전송되는 엔티티에는 적용되지 않는 몇 가지 헤더 필드가 있습니다. 이러한 헤더는 전송되는 메시지에만 적용됩니다.\n\n       일반 헤더 = 날짜 ; 섹션 10.6 | 프라그마 ; 섹션 10.12\n\n   일반 헤더 필드 이름은 프로토콜 버전이 변경된 경우에만 안정적으로 확장할 수 있습니다. 그러나 통신의 모든 당사자가 일반 헤더 필드로 인식하는 경우 새 헤더 필드 또는 실험적인 헤더 필드에 일반 헤더 필드의 의미를 부여할 수 있습니다. 인식되지 않는 헤더 필드는 엔티티-헤더 필드로 취급됩니다.\n\n5. 요청\n\n   클라이언트에서 서버로 보내는 요청 메시지에는 해당 메시지의 첫 줄에 리소스에 적용할 메소드, 리소스의 식별자, 사용 중인 프로토콜 버전이 포함됩니다. 보다 제한된 HTTP/0.9 프로토콜과의 이전 버전과의 호환성을 위해 HTTP 요청에는 두 가지 유효한 형식이 있습니다:\n\n       요청 = 단순 요청 | 전체 요청\n\n       단순 요청 = \"GET\" SP 요청-URI CRLF\n\n       전체 요청 = 요청-라인 ; 섹션 5.1 *( 일반-헤더 ; 섹션 4.3 | 요청-헤더 ; 섹션 5.2 | 엔티티-헤더 ) ; 섹션 7.1 CRLF [ 엔티티-바디 ] ; 섹션 7.2\n\n   HTTP/1.0 서버가 Simple-Request를 수신하면 HTTP/0.9 Simple-Response로 응답해야 합니다. 전체 응답을 수신할 수 있는 HTTP/1.0 클라이언트는 절대로 단순 요청을 생성해서는 안 됩니다.\n\n5.1 요청-라인\n\n   요청-라인은 메소드 토큰으로 시작하여 요청-URI와 프로토콜 버전, 그리고 CRLF로 끝납니다. 각 요소는 SP 문자로 구분됩니다. 마지막 CRLF 시퀀스를 제외하고는 CR 또는 LF는 허용되지 않습니다.\n\n       요청-라인 = 메서드 SP 요청-URI SP HTTP-버전 CRLF\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   단순 요청과 전체 요청의 요청 줄의 차이점은 HTTP-Version 필드의 존재 여부와 GET 이외의 메서드를 사용할 수 있는지 여부입니다.\n\n5.1.1 메서드\n\n   Method 토큰은 Request-URI로 식별된 리소스에서 수행될 메소드를 나타냅니다. 메서드는 대소문자를 구분합니다.\n\n       메소드 = \"GET\" ; 섹션 8.1 | \"HEAD\" ; 섹션 8.2 | \"POST\" ; 섹션 8.3 | extension-method\n\n       extension-method = 토큰\n\n   특정 리소스에서 허용되는 메소드 목록은 동적으로 변경될 수 있으며, 리소스에서 메소드가 허용되지 않는 경우 클라이언트는 응답의 반환 코드를 통해 알림을 받습니다. 서버는 메소드가 인식되지 않거나 구현되지 않은 경우 상태 코드 501(구현되지 않음)을 반환해야 합니다.\n\n   HTTP/1.0 애플리케이션에서 일반적으로 사용되는 메서드는 섹션 8에 자세히 정의되어 있습니다.\n\n5.1.2 요청-URI\n\n   요청-URI는 유니폼 리소스 식별자(섹션 3.2)로, 요청을 적용할 리소스를 식별합니다.\n\n       Request-URI = 절대URI | abs_path\n\n   요청-URI의 두 가지 옵션은 요청의 성격에 따라 달라집니다.\n\n   절대URI 형식은 프록시로 요청하는 경우에만 허용됩니다. 프록시는 요청을 전달하고 응답을 반환하도록 요청받습니다. 요청이 GET 또는 HEAD이고 이전 응답이 캐시된 경우 프록시는 만료 헤더 필드에 있는 제한 사항을 통과하면 캐시된 메시지를 사용할 수 있습니다. 프록시는 요청을 다른 프록시로 전달하거나 절대URI로 지정된 서버로 직접 전달할 수 있습니다. 요청 루프를 방지하려면 프록시는 별칭, 로컬 변형, 숫자 IP 주소를 포함한 모든 서버 이름을 인식할 수 있어야 합니다. 요청 라인의 예는 다음과 같습니다:\n\n       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.0\n\n\n\n버너스 리 등 정보 제공\fRFC 1945 HTTP/1.0 1996년 5월\n\n   가장 일반적인 형태의 Request-URI는 원본 서버 또는 게이트웨이에서 리소스를 식별하는 데 사용됩니다. 이 경우 URI의 절대 경로만 전송됩니다(섹션 3.2.1, abs_path 참조). 예를 들어 원본 서버에서 위의 리소스를 직접 검색하려는 클라이언트는 호스트 \"www.w3.org\"의 포트 80에 대한 TCP 연결을 생성하고 해당 회선을 전송합니다:\n\n       GET /pub/WWW/TheProject.html HTTP/1.0\n\n   다음에 나머지 전체 요청을 전송합니다. 절대 경로는 비워둘 수 없으며, 원본 URI에 경로가 없는 경우 \"/\"(서버 루트)로 지정해야 합니다.\n\n   Request-URI는 인코딩된 문자열로 전송되며, 일부 문자는 RFC 1738[4]에 정의된 \"% HEX HEX\" 인코딩을 사용하여 이스케이프될 수 있습니다. 원본 서버는 요청을 올바르게 해석하기 위해 요청-URI를 디코딩해야 합니다.\n\n5.2 요청 헤더 필드\n\n   요청 헤더 필드를 통해 클라이언트는 요청 및 클라이언트 자체에 대한 추가 정보를 서버에 전달할 수 있습니다. 이러한 필드는 프로그래밍 언어 메서드(프로시저) 호출의 매개변수와 동일한 의미를 갖는 요청 수정자 역할을 합니다.\n\n       요청-헤더 = 권한 부여 ; 섹션 10.2 | 보낸 사람 ; 섹션 10.8 | 수정된 이후 ; 섹션 10.9 | 참조자 ; 섹션 10.13 | 사용자-에이전트 ; 섹션 10.15\n\n   요청 헤더 필드 이름은 프로토콜 버전이 변경된 경우에만 안정적으로 확장할 수 있습니다. 그러나 통신의 모든 당사자가 요청 헤더 필드라고 인식하는 경우 새 헤더 필드 또는 실험적인 헤더 필드에 요청 헤더 필드의 의미를 부여할 수 있습니다. 인식되지 않는 헤더 필드는 엔티티-헤더 필드로 취급됩니다.\n\n6.  응답\n\n   서버는 요청 메시지를 수신하고 해석한 후 HTTP 응답 메시지 형태로 응답합니다.\n\n       응답 = 단순 응답 | 전체 응답\n\n       단순 응답 = [ 엔티티-바디 ]입니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n       전체 응답 = 상태-라인 ; 섹션 6.1 *( 일반-헤더 ; 섹션 4.3 | 응답-헤더 ; 섹션 6.2 | 엔티티-헤더 ) ; 섹션 7.1 CRLF [ 엔티티-바디 ] ; 섹션 7.2\n\n   단순 응답은 HTTP/0.9 단순 요청에 대한 응답으로만 전송하거나 서버가 보다 제한된 HTTP/0.9 프로토콜만 지원하는 경우에만 전송해야 합니다. 클라이언트가 HTTP/1.0 Full-Request를 전송하고 Status-Line으로 시작하지 않는 응답을 수신하는 경우, 해당 응답이 Simple-Response라고 가정하고 그에 따라 파싱해야 합니다. 단순 응답은 엔티티 본문으로만 구성되며 서버가 연결을 종료하면 종료된다는 점에 유의하세요.\n\n6.1 Status-Line\n\n   전체 응답 메시지의 첫 줄은 프로토콜 버전과 숫자 상태 코드 및 관련 텍스트 구문으로 구성된 상태 줄이며, 각 요소는 SP 문자로 구분됩니다. 마지막 CRLF 시퀀스를 제외하고는 CR 또는 LF는 허용되지 않습니다.\n\n       Status-Line = HTTP-버전 SP 상태 코드 SP 이유-구문 CRLF\n\n   상태 줄은 항상 프로토콜 버전과 상태 코드로 시작하므로\n\n       \"HTTP/\" 1*숫자 \".\" 1*숫자 SP 3*숫자 SP\n\n   (예: \"HTTP/1.0 200\")로 시작하므로 해당 표현식의 존재만으로도 전체 응답과 단순 응답을 구분할 수 있습니다.   단순 응답 형식은 엔티티 본문의 시작 부분에 이러한 표현식을 허용하여 전체 요청에 대한 응답으로 제공된 경우 메시지를 잘못 해석할 수 있지만, 대부분의 HTTP/0.9 서버는 \"text/html\" 유형의 응답으로 제한되므로 이러한 응답은 절대 생성하지 않습니다.\n\n6.1.1 상태 코드 및 이유 문구\n\n   Status-Code 요소는 요청을 이해하고 충족시키려는 시도에 대한 3자리 정수 결과 코드입니다. 이유 문구는 상태 코드에 대한 간단한 텍스트 설명을 제공하기 위한 것입니다. 상태 코드는 오토마타에서 사용하기 위한 것이고 이유 문구는 인간 사용자를 위한 것입니다. 클라이언트는 이유 문구를 검토하거나 표시할 필요가 없습니다.\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   상태 코드의 첫 번째 숫자는 응답의 클래스를 정의합니다. 마지막 두 자리는 어떤 분류 역할도 하지 않습니다. 첫 번째 숫자에는 5개의 값이 있습니다:\n\n      o 1xx: 정보 - 사용되지는 않지만 향후 사용을 위해 예약됨\n\n      o 2xx: 성공 - 작업을 성공적으로 수신, 이해 및 수락했습니다.\n\n      o 3xx: 리디렉션 - 요청을 완료하려면 추가 조치를 취해야 합니다.\n\n      o 4xx: 클라이언트 오류 - 요청에 잘못된 구문이 포함되어 있거나 요청을 이행할 수 없습니다.\n\n      o 5xx: 서버 오류 - 서버가 명백히 유효한 요청을 처리하지 못했습니다.\n\n   HTTP/1.0에 정의된 숫자 상태 코드의 개별 값과 해당 이유 문구의 예시는 아래와 같습니다. 여기에 나열된 이유 구문은 권장 사항일 뿐이며 프로토콜에 영향을 주지 않고 로컬에 상응하는 것으로 대체할 수 있습니다. 이러한 코드는 섹션 9에 완전히 정의되어 있습니다.\n\n       Status-Code = \"200\" ; 확인 | \"201\" ; 생성됨 | \"202\" ; 수락됨 | \"204\" ; 콘텐츠 없음 | \"301\" ; 영구 이동 | \"302\" ; 일시 이동 | \"304\" ; 수정되지 않음 | \"400\" ; 잘못된 요청 | \"401\" ; 권한 없음 | \"403\" ; 금지됨 | \"404\" ; 찾을 수 없음 | \"500\" ; 내부 서버 오류 | \"501\" ; 구현됨 없음 | \"502\" ; 나쁜 게이트웨이 | \"503\" ; 서비스를 사용할 수 없음 확장-코드\n\n       확장 코드 = 3DIGIT\n\n       Reason-Phrase = *&lt;TEXT, CR, LF 제외;\n\n   HTTP 상태 코드는 확장 가능하지만 현재 실무에서 일반적으로 인정되는 코드는 위의 코드뿐입니다. HTTP 애플리케이션이 등록된 모든 상태의 의미를 이해할 필요는 없습니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   코드를 이해하는 것이 분명히 바람직합니다. 그러나 애플리케이션은 인식할 수 없는 응답을 캐시해서는 안 된다는 점을 제외하고는 첫 번째 숫자로 표시되는 상태 코드의 클래스를 이해하고 인식할 수 없는 응답을 해당 클래스의 x00 상태 코드와 동일한 것으로 취급해야 합니다. 예를 들어 클라이언트가 인식할 수 없는 상태 코드 431을 수신하면 요청에 문제가 있는 것으로 간주하고 400 상태 코드를 수신한 것처럼 응답을 처리할 수 있습니다. 이러한 경우 사용자 상담원은 응답과 함께 반환된 엔티티에 비정상적인 상태를 설명할 수 있는 사람이 읽을 수 있는 정보가 포함되어 있을 가능성이 높으므로 해당 엔티티를 사용자에게 제시해야 합니다.\n\n6.2 응답 헤더 필드\n\n   응답 헤더 필드를 사용하면 서버가 상태 표시줄에 넣을 수 없는 응답에 대한 추가 정보를 전달할 수 있습니다. 이러한 헤더 필드는 서버에 대한 정보와 요청 URL로 식별된 리소스에 대한 추가 액세스에 대한 정보를 제공합니다.\n\n       응답 헤더 = 위치 ; 섹션 10.11 | 서버 ; 섹션 10.14 | WWW-인증 ; 섹션 10.16\n\n   응답 헤더 필드 이름은 프로토콜 버전이 변경된 경우에만 안정적으로 확장할 수 있습니다. 그러나 통신의 모든 당사자가 응답 헤더 필드라고 인식하는 경우 새 헤더 필드 또는 실험적인 헤더 필드에 응답 헤더 필드의 의미를 부여할 수 있습니다. 인식되지 않는 헤더 필드는 엔티티-헤더 필드로 취급됩니다.\n\n7.  Entity\n\n   전체 요청 및 전체 응답 메시지는 일부 요청 및 응답 내에 엔티티를 전송할 수 있습니다. 엔티티는 엔티티-헤더 필드와 (보통) 엔티티-바디로 구성됩니다. 이 섹션에서 발신자와 수신자 모두 엔티티를 보내는 사람과 받는 사람에 따라 클라이언트 또는 서버를 가리킵니다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n7.1 엔티티 헤더 필드\n\n   엔티티 헤더 필드는 엔티티 바디에 대한 선택적 메타정보를 정의하거나, 바디가 없는 경우 요청에 의해 식별된 리소스에 대한 메타정보를 정의합니다.\n\n       엔티티 헤더 = 허용, 섹션 10.1 | 콘텐츠 인코딩, 섹션 10.3 | 콘텐츠 길이, 섹션 10.4 | 콘텐츠 유형, 섹션 10.5 | 만료, 섹션 10.7 | 마지막 수정, 섹션 10.10 | 확장 헤더\n\n       확장 헤더 = HTTP-헤더\n\n   extension-header 메커니즘을 사용하면 프로토콜을 변경하지 않고도 추가 엔티티-헤더 필드를 정의할 수 있지만 이러한 필드는 수신자가 인식할 수 있다고 가정할 수 없습니다. 인식할 수 없는 헤더 필드는 수신자가 무시하고 프록시를 통해 전달해야 합니다.\n\n7.2 엔티티 본문\n\n   HTTP 요청 또는 응답과 함께 전송되는 엔티티 본문(있는 경우)은 엔티티-헤더 필드에 정의된 형식과 인코딩을 따릅니다.\n\n       엔티티 본문 = *OCTET\n\n   엔티티 본문은 요청 메서드가 엔티티 본문을 호출하는 경우에만 요청 메시지에 포함됩니다. 요청에 엔티티 본문이 있다는 것은 요청 메시지 헤더에 Content-Length 헤더 필드가 포함됨으로써 알 수 있습니다. 엔티티 본문이 포함된 HTTP/1.0 요청에는 유효한 Content-Length 헤더 필드가 포함되어야 합니다.\n\n   응답 메시지의 경우 엔티티 본문이 메시지에 포함되는지 여부는 요청 메서드와 응답 코드에 따라 달라집니다. HEAD 요청 메서드에 대한 모든 응답에는 엔티티 헤더 필드가 있어 본문을 포함한다고 생각할 수 있지만 본문을 포함하지 않아야 합니다. 모든 1xx(정보 제공), 204(콘텐츠 없음), 304(수정되지 않음) 응답에는 본문이 포함되어서는 안 됩니다. 다른 모든 응답에는 엔티티 본문 또는 0(0) 값으로 정의된 Content-Length 헤더 필드가 포함되어야 합니다.\n\n7.2.1 유형\n\n   엔티티 본문이 메시지에 포함된 경우 해당 본문의 데이터 유형은 헤더 필드 Content-Type 및 Content- Encoding을 통해 결정됩니다. 이는 2계층의 정렬된 인코딩 모델을 정의합니다:\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n       엔티티 본문 := 콘텐츠-인코딩( 콘텐츠-타입( 데이터 ) )\n\n   Content-Type은 기본 데이터의 미디어 타입을 지정합니다. Content-Encoding은 일반적으로 데이터 압축을 위해 유형에 적용된 추가 콘텐츠 코딩을 나타내는 데 사용할 수 있으며, 이는 요청된 리소스의 속성입니다. 콘텐츠 인코딩의 기본값은 없음(즉, ID 함수)입니다.\n\n   엔티티 본문이 포함된 모든 HTTP/1.0 메시지에는 해당 본문의 미디어 타입을 정의하는 Content-Type 헤더 필드가 포함되어야 합니다. 단순 응답 메시지의 경우처럼 Content-Type 헤더에 미디어 유형이 제공되지 않는 경우에만 수신자는 해당 콘텐츠 및/또는 리소스 식별에 사용된 URL의 이름 확장자를 검사하여 미디어 유형을 추측할 수 있습니다. 미디어 유형을 알 수 없는 경우 수신자는 이를 \"application/octet-stream\" 유형으로 처리해야 합니다.\n\n7.2.2 길이\n\n   엔티티 본문이 메시지에 포함된 경우 해당 본문의 길이는 다음 두 가지 방법 중 하나로 결정될 수 있습니다. Content-Length 헤더 필드가 있는 경우, 그 바이트 단위의 값이 Entity-Body의 길이를 나타냅니다. 그렇지 않으면 서버가 연결을 닫을 때 본문 길이가 결정됩니다.\n\n   연결을 닫으면 서버가 응답을 다시 보낼 가능성이 없으므로 요청 본문의 끝을 나타내는 데 사용할 수 없습니다. 따라서 엔티티 본문이 포함된 HTTP/1.0 요청에는 유효한 Content-Length 헤더 필드가 포함되어야 합니다. 요청에 엔티티 본문이 포함되어 있는데 Content-Length가 지정되지 않았고 서버가 다른 필드에서 길이를 인식하지 못하거나 계산할 수 없는 경우 서버는 400(잘못된 요청) 응답을 보내야 합니다.\n\n      참고: 일부 구형 서버는 데이터 스트림에 동적으로 삽입된 서버 측 포함이 포함된 문서를 전송할 때 잘못된 Content-Length를 제공합니다. 이는 향후 버전의 HTTP에서는 허용되지 않는다는 점을 강조해야 합니다. 클라이언트가 규정을 준수하는 서버로부터 응답을 수신하고 있다는 것을 알지 못하는 한, Content-Length 값이 올바른지 여부에 의존해서는 안 됩니다.\n\n8.  메서드 정의\n\n   HTTP/1.0의 일반적인 메소드 집합은 아래에 정의되어 있습니다. 이 집합은 확장될 수 있지만, 추가 메소드가 별도로 확장된 클라이언트와 서버에 대해 동일한 의미를 공유한다고 가정할 수는 없습니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n8.1 GET\n\n   GET 메서드는 요청-URI에 의해 식별되는 모든 정보(엔티티 형태)를 검색하는 것을 의미합니다. 요청-URI가 데이터를 생성하는 프로세스를 참조하는 경우, 해당 텍스트가 프로세스의 출력인 경우를 제외하고는 프로세스의 소스 텍스트가 아닌 생성된 데이터가 응답의 엔티티로 반환되어야 합니다.\n\n   요청 메시지에 If-Modified-Since 헤더 필드가 포함된 경우 GET 메서드의 의미는 \"조건부 GET\"으로 변경됩니다. 조건부 GET 메서드는 10.9절에 설명된 대로 If-Modified-Since 헤더에 지정된 날짜 이후에 수정된 경우에만 식별된 리소스를 전송하도록 요청합니다. 조건부 GET 메서드는 여러 번 요청하거나 불필요한 데이터를 전송할 필요 없이 캐시된 엔티티를 새로 고칠 수 있도록 하여 네트워크 사용량을 줄이기 위한 것입니다.\n\n8.2 HEAD\n\n   HEAD 메서드는 서버가 응답에 엔티티-바디를 반환하지 않아야 한다는 점을 제외하면 GET과 동일합니다. HEAD 요청에 대한 응답으로 HTTP 헤더에 포함된 메타정보는 GET 요청에 대한 응답으로 전송된 정보와 동일해야 합니다. 이 메서드는 엔티티-바디 자체를 전송하지 않고 요청-URI로 식별된 리소스에 대한 메타정보를 얻는 데 사용할 수 있습니다. 이 방법은 하이퍼텍스트 링크의 유효성, 접근성 및 최근 수정 여부를 테스트하는 데 자주 사용됩니다.\n\n   조건부 GET과 유사한 \"조건부 HEAD\" 요청은 없습니다. If-Modified-Since 헤더 필드가 HEAD 요청에 포함되어 있으면 무시해야 합니다.\n\n8.3 POST\n\n   POST 메서드는 대상 서버가 요청에 포함된 엔티티를 요청 라인의 Request-URI로 식별된 리소스의 새 하위 항목으로 수락하도록 요청하는 데 사용됩니다. POST는 다음과 같은 기능을 통일된 방법으로 처리할 수 있도록 설계되었습니다:\n\n      o 기존 리소스에 대한 어노테이션;\n\n      o 게시판, 뉴스그룹, 메일링 리스트 또는 이와 유사한 글 그룹에 메시지 게시;\n\n      o 데이터 처리 프로세스에 양식[3]을 제출한 결과와 같은 데이터 블록을 제공하는 행위;\n\n      o 추가 작업을 통해 데이터베이스 확장.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   POST 메서드가 수행하는 실제 기능은 서버에 의해 결정되며 일반적으로 요청-URI에 따라 달라집니다. 게시된 엔티티는 파일이 포함된 디렉토리에 종속되거나, 뉴스 기사가 게시된 뉴스 그룹에 종속되거나, 레코드가 데이터베이스에 종속되는 것과 같은 방식으로 해당 URI에 종속됩니다.\n\n   성공적인 POST는 엔티티를 원본 서버에서 리소스로 만들거나 나중에 참조할 수 있도록 액세스할 수 있도록 만들 필요가 없습니다. 즉, POST 메서드에 의해 수행된 작업으로 인해 URI로 식별할 수 있는 리소스가 생성되지 않을 수 있습니다. 이 경우 응답에 결과를 설명하는 엔티티가 포함되어 있는지 여부에 따라 200(확인) 또는 204(콘텐츠 없음)가 적절한 응답 상태입니다.\n\n   원본 서버에서 리소스가 생성된 경우 응답은 201(생성됨)이며 요청의 상태를 설명하고 새 리소스를 참조하는 엔티티(바람직하게는 \"text/html\" 유형)를 포함해야 합니다.\n\n   모든 HTTP/1.0 POST 요청에는 유효한 Content-Length가 필요합니다. HTTP/1.0 서버는 요청 메시지의 콘텐츠 길이를 확인할 수 없는 경우 400(잘못된 요청) 메시지로 응답해야 합니다.\n\n   애플리케이션은 서버가 향후 요청에 대해 동일한 응답을 반환할지 알 수 없으므로 POST 요청에 대한 응답을 캐시해서는 안 됩니다.\n\n9.  상태 코드 정의\n\n   각 상태 코드는 아래에 설명되어 있으며, 어떤 메소드를 따를 수 있는지와 응답에 필요한 메타정보가 포함되어 있습니다.\n\n9.1 정보 1xx\n\n   이 상태 코드 클래스는 Status-Line과 선택적 헤더로만 구성된 임시 응답을 나타내며 빈 줄로 끝납니다. HTTP/1.0은 1xx 상태 코드를 정의하지 않으며 HTTP/1.0 요청에 대한 유효한 응답이 아닙니다.   그러나 이 사양의 범위를 벗어난 실험적인 애플리케이션에는 유용할 수 있습니다.\n\n9.2 성공적인 2xx\n\n   이 상태 코드 클래스는 클라이언트의 요청이 성공적으로 수신, 이해 및 수락되었음을 나타냅니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   200 OK\n\n   요청이 성공했습니다. 응답으로 반환되는 정보는 요청에 사용된 방법에 따라 다음과 같이 달라집니다:\n\n   GET은 요청된 리소스에 해당하는 엔티티가 응답으로 전송됩니다;\n\n   HEAD 응답에는 헤더 정보만 포함되어야 하며 엔티티 본문은 포함되지 않아야 합니다;\n\n   POST 작업 결과를 설명하거나 포함하는 엔티티.\n\n   201 Created\n\n   요청이 처리되어 새 리소스가 생성되었습니다. 새로 생성된 리소스는 응답의 엔티티에 반환된 URI로 참조할 수 있습니다. 원본 서버는 이 상태 코드를 사용하기 전에 리소스를 생성해야 합니다. 작업을 즉시 수행할 수 없는 경우 서버는 리소스를 언제 사용할 수 있는지에 대한 설명을 응답 본문에 포함해야 하며, 그렇지 않은 경우 202(수락됨)로 응답해야 합니다.\n\n   이 사양에 정의된 메서드 중 POST만 리소스를 생성할 수 있습니다.\n\n   202 수락됨\n\n   요청이 처리를 위해 수락되었지만 처리가 완료되지 않았습니다. 요청이 실제로 처리될 때 허용되지 않을 수 있으므로 요청이 최종적으로 처리될 수도 있고 처리되지 않을 수도 있습니다. 이와 같은 비동기 작업에서 상태 코드를 다시 전송하는 기능은 없습니다.\n\n   202 응답은 의도적으로 커밋되지 않습니다. 그 목적은 프로세스가 완료될 때까지 사용자 에이전트의 서버 연결이 유지될 필요 없이 서버가 다른 프로세스(예: 하루에 한 번만 실행되는 배치 지향 프로세스)에 대한 요청을 수락할 수 있도록 하기 위한 것입니다. 이 응답과 함께 반환되는 엔티티에는 요청의 현재 상태에 대한 표시와 상태 모니터에 대한 포인터 또는 사용자가 요청이 완료될 것으로 예상할 수 있는 예상 시간이 포함되어야 합니다.\n\n   204 콘텐츠 없음\n\n   서버가 요청을 처리했지만 다시 보낼 새 정보가 없는 경우입니다. 클라이언트가 사용자 에이전트인 경우 요청을 일으킨 문서 보기를 다음과 같이 변경해서는 안 됩니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   을 생성합니다. 이 응답은 주로 사용자 에이전트의 활성 문서 보기를 변경하지 않고 스크립트 또는 기타 작업을 위한 입력을 허용하기 위한 것입니다. 응답에는 현재 사용자 에이전트의 활성 보기에 있는 문서에 적용되어야 하는 엔티티 헤더 형태의 새로운 메타 정보가 포함될 수 있습니다.\n\n9.3 리디렉션 3xx\n\n   이 상태 코드 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다. 필요한 작업은 후속 요청에 사용된 메서드가 GET 또는 HEAD인 경우에만 사용자와의 상호 작용 없이 사용자 에이전트가 수행할 수 있습니다. 사용자 에이전트는 요청을 5회 이상 자동으로 리디렉션해서는 안 되며, 이러한 리디렉션은 일반적으로 무한 루프를 의미하기 때문입니다.\n\n   300 다중 선택\n\n   이 응답 코드는 HTTP/1.0 애플리케이션에서 직접 사용되지는 않지만 3xx 클래스 응답을 해석할 때 기본값으로 사용됩니다.\n\n   요청된 리소스는 하나 이상의 위치에서 사용할 수 있습니다.   HEAD 요청이 아닌 한, 응답에는 사용자 또는 사용자 에이전트가 가장 적합한 리소스를 선택할 수 있는 리소스 특성 및 위치 목록이 포함된 엔티티가 포함되어야 합니다.   서버에 선호하는 선택지가 있는 경우 위치 필드에 URL을 포함해야 하며, 사용자 상담원은 이 필드 값을 사용하여 자동 리디렉션할 수 있습니다.\n\n   301 영구적으로 이동됨\n\n   요청된 리소스에 새 영구 URL이 할당되었으며 향후 이 리소스에 대한 모든 참조는 해당 URL을 사용하여 수행해야 합니다. 링크 편집 기능이 있는 클라이언트는 가능한 경우 서버가 반환한 새 참조로 요청-URI에 대한 참조를 자동으로 리링크해야 합니다.\n\n   새 URL은 응답의 위치 필드에 제공되어야 합니다.   HEAD 요청이 아니라면 응답의 엔티티 본문에는 새 URL로 연결되는 하이퍼링크가 포함된 짧은 메모가 포함되어야 합니다.\n\n   POST 메서드를 사용한 요청에 대한 응답으로 301 상태 코드가 수신되면 요청이 발행된 조건이 변경될 수 있으므로 사용자가 확인할 수 없는 한 사용자 에이전트는 요청을 자동으로 리디렉션해서는 안 됩니다.\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n       참고: 301 상태 코드를 수신한 후 POST 요청을 자동으로 리디렉션할 때 일부 기존 사용자 에이전트는 이를 GET 요청으로 잘못 변경합니다.\n\n   302 일시적으로 이동됨\n\n   요청된 리소스가 일시적으로 다른 URL에 있습니다.   리디렉션은 때때로 변경될 수 있으므로 클라이언트는 향후 요청에 대해 Request-URI를 계속 사용해야 합니다.\n\n   URL은 응답의 위치 필드에 제공해야 합니다. HEAD 요청이 아니라면 응답의 엔티티 본문에는 새 URI로 연결되는 하이퍼링크가 포함된 짧은 메모가 포함되어야 합니다.\n\n   POST 방식을 사용한 요청에 대한 응답으로 302 상태 코드가 수신되는 경우 요청이 발행된 조건이 변경될 수 있으므로 사용자가 확인할 수 없는 한 사용자 에이전트는 요청을 자동으로 리디렉션해서는 안 됩니다.\n\n       참고: 302 상태 코드를 수신한 후 POST 요청을 자동으로 리디렉션하는 경우 일부 기존 사용자 에이전트는 이를 GET 요청으로 잘못 변경할 수 있습니다.\n\n   304 수정되지 않음\n\n   클라이언트가 조건부 GET 요청을 수행했고 액세스가 허용되었지만 If-Modified-Since 필드에 지정된 날짜 및 시간 이후 문서가 수정되지 않은 경우 서버는 이 상태 코드로 응답해야 하며 클라이언트에게 Entity-Body를 보내서는 안 됩니다. 응답에 포함된 헤더 필드에는 캐시 관리자와 관련이 있거나 엔티티의 마지막 수정 날짜와는 독립적으로 변경되었을 수 있는 정보만 포함되어야 합니다. 관련 헤더 필드의 예는 다음과 같습니다: 날짜, 서버 및 만료. 캐시는 304 응답에 제공된 새 필드 값을 반영하도록 캐시된 엔티티를 업데이트해야 합니다.\n\n9.4 클라이언트 오류 4xx\n\n   4xx 상태 코드 클래스는 클라이언트에 오류가 발생한 것으로 보이는 경우를 위한 것입니다. 클라이언트가 4xx 코드를 수신했을 때 요청을 완료하지 않은 경우 즉시 서버로의 데이터 전송을 중단해야 합니다. HEAD 요청에 응답할 때를 제외하고 서버는 오류 상황에 대한 설명과 일시적인 상태인지 영구적인 상태인지에 대한 설명이 포함된 엔티티를 포함해야 합니다. 이러한 상태 코드는 모든 요청 방법에 적용할 수 있습니다.\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n      참고: 클라이언트가 데이터를 전송하는 경우, TCP의 서버 구현은 입력 연결을 닫기 전에 클라이언트가 응답이 포함된 패킷의 수신을 확인하도록 주의해야 합니다. 닫은 후에도 클라이언트가 서버에 데이터를 계속 전송하면 서버의 컨트롤러가 클라이언트에 리셋 패킷을 전송하여 클라이언트의 승인되지 않은 입력 버퍼가 HTTP 애플리케이션에서 읽고 해석하기 전에 지워질 수 있습니다.\n\n   400 잘못된 요청\n\n   잘못된 구문으로 인해 서버가 요청을 이해할 수 없습니다. 클라이언트는 수정 없이 요청을 반복해서는 안 됩니다.\n\n   401 권한 없음\n\n   요청에 사용자 인증이 필요합니다. 응답에는 요청된 리소스에 적용할 수 있는 챌린지가 포함된 WWW-Authenticate 헤더 필드(섹션 10.16)가 포함되어야 합니다. 클라이언트는 적절한 권한 부여 헤더 필드를 사용하여 요청을 반복할 수 있습니다(섹션 10.2). 요청에 이미 권한 부여 자격 증명이 포함된 경우 401 응답은 해당 자격 증명에 대한 권한 부여가 거부되었음을 나타냅니다. 401 응답에 이전 응답과 동일한 챌린지가 포함되어 있고 사용자 에이전트가 이미 한 번 이상 인증을 시도한 경우, 해당 엔티티에 관련 진단 정보가 포함될 수 있으므로 사용자에게 응답에 제공된 엔티티를 제시해야 합니다. HTTP 액세스 인증은 섹션 11에 설명되어 있습니다.\n\n   403 금지\n\n   서버가 요청을 이해했지만 이행을 거부하고 있습니다.   권한 부여는 도움이 되지 않으며 요청을 반복해서는 안 됩니다.   요청 메서드가 HEAD가 아니고 서버가 요청을 처리하지 않은 이유를 공개하려는 경우 엔티티 본문에 거부 이유를 설명해야 합니다. 이 상태 코드는 서버가 요청이 거부된 이유를 정확히 밝히고 싶지 않거나 다른 응답이 적용되지 않을 때 일반적으로 사용됩니다.\n\n   404 찾을 수 없음\n\n   서버에서 요청 URL과 일치하는 항목을 찾지 못했습니다. 이 상태가 일시적인지 영구적인지 여부는 표시되지 않습니다. 서버가 이 정보를 클라이언트에 제공하지 않으려는 경우 상태 코드 403(금지됨)을 대신 사용할 수 있습니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n9.5 서버 오류 5xx\n\n   숫자 '5'로 시작하는 응답 상태 코드는 서버가 오류를 인식했거나 요청을 수행할 수 없는 경우를 나타냅니다. 클라이언트가 5xx 코드를 수신했을 때 요청을 완료하지 않았다면 즉시 서버로의 데이터 전송을 중단해야 합니다. HEAD 요청에 응답하는 경우를 제외하고 서버는 오류 상황에 대한 설명과 일시적인 상태인지 영구적인 상태인지에 대한 설명이 포함된 엔티티를 포함해야 합니다.   이러한 응답 코드는 모든 요청 방법에 적용할 수 있으며 필수 헤더 필드는 없습니다.\n\n   500 내부 서버 오류\n\n   서버에서 예기치 않은 조건이 발생하여 요청을 처리할 수 없습니다.\n\n   501 구현되지 않음\n\n   서버가 요청을 처리하는 데 필요한 기능을 지원하지 않습니다. 서버가 요청 방법을 인식하지 못하고 리소스에 대해 이를 지원할 수 없는 경우 적절한 응답입니다.\n\n   502 잘못된 게이트웨이\n\n   서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 처리하기 위해 액세스한 업스트림 서버로부터 잘못된 응답을 받았습니다.\n\n   503 서비스를 사용할 수 없음\n\n   서버의 일시적인 과부하 또는 유지 관리로 인해 서버가 현재 요청을 처리할 수 없습니다. 이는 일시적인 상태이며 잠시 후 완화될 것이라는 의미입니다.\n\n       참고: 503 상태 코드가 존재한다고 해서 서버가 과부하 상태일 때 반드시 이 코드를 사용해야 한다는 의미는 아닙니다. 일부 서버는 단순히 연결을 거부할 수도 있습니다.\n\n10.  헤더 필드 정의\n\n   이 섹션에서는 일반적으로 사용되는 모든 HTTP/1.0 헤더 필드의 구문과 의미를 정의합니다. 일반 및 엔티티 헤더 필드의 경우 발신자와 수신자 모두 메시지를 보내는 사람과 받는 사람에 따라 클라이언트 또는 서버를 참조합니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n10.1 허용\n\n   허용 엔티티 헤더 필드에는 요청-URI로 식별된 리소스가 지원하는 메소드 집합이 나열됩니다. 이 필드의 목적은 리소스와 관련된 유효한 메소드를 수신자에게 알리는 것입니다. 허용 헤더 필드는 POST 메서드를 사용하는 요청에서는 허용되지 않으므로 POST 엔티티의 일부로 수신되는 경우 무시해야 합니다.\n\n       허용 = \"허용\" \":\" 1#메소드\n\n    사용 예시:\n\n       Allow: GET, HEAD\n\n   이 필드는 클라이언트가 다른 방법을 시도하는 것을 막을 수 없습니다.   그러나 허용 헤더 필드 값의 표시를 따라야 합니다. 허용되는 메소드의 실제 집합은 각 요청 시점에 원본 서버에서 정의합니다.\n\n   사용자 에이전트가 원본 서버와 통신하는 다른 수단이 있을 수 있으므로 프록시는 지정된 모든 메소드를 이해하지 못하더라도 허용 헤더 필드를 수정해서는 안 됩니다.\n\n   허용 헤더 필드에는 서버가 구현하는 메소드가 표시되지 않습니다.\n\n10.2 권한 부여\n\n   401 응답을 받은 후 서버에 자신을 인증하려는 사용자 에이전트는 일반적으로(반드시 그렇지는 않지만) 요청에 Authorization 요청 헤더 필드를 포함시켜 인증할 수 있습니다. 권한 부여 필드 값은 요청되는 리소스의 영역에 대한 사용자 에이전트의 인증 정보가 포함된 자격 증명으로 구성됩니다.\n\n       Authorization = \"권한 부여\" \":\" 자격 증명\n\n   HTTP 액세스 인증은 섹션 11에 설명되어 있습니다. 요청이 인증되고 영역이 지정된 경우, 이 영역 내의 다른 모든 요청에 대해 동일한 자격 증명이 유효해야 합니다.\n\n   권한 부여 필드가 포함된 요청에 대한 응답은 캐시할 수 없습니다.\n\n\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n10.3 콘텐츠 인코딩\n\n   Content-Encoding 엔티티 헤더 필드는 미디어 타입에 대한 수정자로 사용됩니다. 이 값이 있으면 리소스에 어떤 추가 콘텐츠 코딩이 적용되었는지, 따라서 Content-Type 헤더 필드에서 참조하는 미디어 유형을 얻기 위해 어떤 디코딩 메커니즘을 적용해야 하는지를 나타냅니다. Content-Encoding은 주로 기본 미디어 유형의 신원을 잃지 않고 문서를 압축할 수 있도록 하는 데 사용됩니다.\n\n       콘텐츠-인코딩 = \"콘텐츠-인코딩\" \":\" 콘텐츠-코딩\n\n   콘텐츠 코딩은 섹션 3.5에 정의되어 있습니다. 사용 예는 다음과 같습니다.\n\n       콘텐츠-인코딩: x-gzip\n\n   Content-Encoding은 Request-URI로 식별되는 리소스의 특성입니다. 일반적으로 리소스는 이 인코딩으로 저장되며 렌더링 또는 이와 유사한 사용 전에만 디코딩됩니다.\n\n10.4 콘텐츠 길이\n\n   Content-Length 엔티티 헤더 필드는 수신자에게 전송된 엔티티 바디의 크기를 십진수 옥텟으로 나타내거나, HEAD 메서드의 경우 요청이 GET이었을 경우 전송되었을 엔티티 바디의 크기를 나타냅니다.\n\n       Content-Length = \"Content-Length\" \":\" 1*DIGIT\n\n   예를 들면 다음과 같습니다.\n\n       Content-Length: 3495\n\n   애플리케이션은 엔티티의 미디어 유형에 관계없이 이 필드를 사용하여 전송할 엔티티 바디의 크기를 표시해야 합니다. 엔티티 본문이 포함된 모든 HTTP/1.0 요청 메시지에는 유효한 Content-Length 필드 값이 필요합니다.\n\n   0보다 크거나 같은 모든 Content-Length가 유효한 값입니다.   7.2.2 섹션에서는 Content-Length가 제공되지 않은 경우 응답 엔티티 본문의 길이를 결정하는 방법에 대해 설명합니다.\n\n      참고: 이 필드의 의미는 \"메시지/외부 본문\" 콘텐츠 유형 내에서 사용되는 선택적 필드인 MIME의 해당 정의와 크게 다릅니다. HTTP에서는 전송되기 전에 엔티티의 길이를 확인할 수 있을 때마다 이 필드를 사용해야 합니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n10.5 콘텐츠 유형\n\n   Content-Type 엔티티 헤더 필드는 수신자에게 전송된 엔티티-바디의 미디어 타입을 나타내거나 HEAD 메서드의 경우 요청이 GET이었을 때 전송되었을 미디어 타입을 나타냅니다.\n\n       Content-Type = \"콘텐츠 유형\" \":\" 미디어 유형\n\n   미디어 유형은 섹션 3.6에 정의되어 있습니다. 필드의 예는 다음과 같습니다.\n\n       콘텐츠 유형: 텍스트/html\n\n   엔티티의 미디어 유형을 식별하는 방법에 대한 자세한 설명은 섹션 7.2.1에 나와 있습니다.\n\n10.6 날짜\n\n   Date 일반 헤더 필드는 메시지가 시작된 날짜와 시간을 나타내며, RFC 822의 orig-date와 동일한 의미를 갖습니다. 필드 값은 섹션 3.3에 설명된 대로 HTTP-date입니다.\n\n       Date = \"날짜\" \":\" HTTP-date\n\n   예시는 다음과 같습니다.\n\n       Date: Tue, 15 Nov 1994 08:12:31 GMT\n\n   사용자 에이전트(요청의 경우) 또는 원본 서버(응답의 경우)와의 직접 연결을 통해 메시지를 수신하는 경우 날짜는 수신 측의 현재 날짜로 간주할 수 있습니다. 그러나 원본 서버가 생각하는 날짜는 캐시된 응답을 평가하는 데 중요하므로 원본 서버는 항상 날짜 헤더를 포함해야 합니다. 클라이언트는 POST 요청의 경우처럼 엔티티 본문이 포함된 메시지에만 날짜 헤더 필드를 보내야 하며, 이 경우에도 선택 사항입니다. 날짜 헤더 필드가 없는 수신 메시지가 해당 수신자에 의해 캐시되거나 날짜가 필요한 프로토콜을 통해 게이트웨이 처리되는 경우 수신자가 날짜 헤더 필드를 할당해야 합니다.\n\n   이론적으로 날짜는 엔티티가 생성되기 직전의 순간을 나타내야 합니다. 실제로 날짜는 메시지의 의미 값에 영향을 주지 않고 메시지가 생성되는 동안 언제든지 생성될 수 있습니다.\n\n      참고: 이 문서의 이전 버전에서는 이 필드에 동봉된 엔티티-바디의 생성 날짜가 포함되어야 한다고 잘못 지정되어 있었습니다. 이는 실제 (그리고 적절한) 날짜를 반영하도록 변경되었습니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n      사용법.\n\n10.7 만료\n\n   만료 엔터티 헤더 필드에는 해당 엔터티가 오래된 것으로 간주되는 날짜/시간이 표시됩니다. 이를 통해 정보 제공자는 리소스의 변동성 또는 정보가 더 이상 유효하지 않을 수 있는 날짜를 제시할 수 있습니다. 애플리케이션은 지정된 날짜 이후에 이 엔티티를 캐시해서는 안 됩니다. 만료 필드가 있다고 해서 해당 날짜 이전이나 이후에 원본 리소스가 변경되거나 존재하지 않게 된다는 의미는 아닙니다. 그러나 리소스가 특정 날짜까지 변경될 것을 알고 있거나 의심하는 정보 제공업체는 해당 날짜가 포함된 Expires 헤더를 포함해야 합니다. 형식은 섹션 3.3의 HTTP-date에 정의된 절대 날짜와 시간입니다.\n\n       Expires = \"Expires\" \":\" HTTP-date\n\n   사용 예는 다음과 같습니다.\n\n       Expires: Thu, 01 Dec 1994 16:00:00 GMT\n\n   지정된 날짜가 Date 헤더의 값과 같거나 이보다 빠르면 수신자는 묶인 엔티티를 캐시하지 않아야 합니다. 많은 데이터 생성 프로세스의 경우처럼 리소스가 본질적으로 동적인 경우 해당 리소스의 엔티티에는 이러한 동적 특성을 반영하는 적절한 Expires 값을 지정해야 합니다.\n\n   Expires 필드는 사용자 에이전트가 디스플레이를 새로 고치거나 리소스를 다시 로드하도록 강제하는 데 사용할 수 없으며, 그 의미는 캐싱 메커니즘에만 적용되며 이러한 메커니즘은 해당 리소스에 대한 새 요청이 시작될 때만 리소스의 만료 상태를 확인하면 됩니다.\n\n   사용자 에이전트에는 종종 '뒤로' 버튼 및 히스토리 목록과 같은 히스토리 메커니즘이 있으며, 이를 사용하여 세션 초기에 검색된 엔티티를 다시 표시할 수 있습니다. 기본적으로 만료 필드는 기록 메커니즘에 적용되지 않습니다. 엔티티가 아직 저장소에 있는 경우에는 사용자가 만료된 기록 문서를 새로 고치도록 에이전트를 특별히 구성하지 않는 한 엔티티가 만료된 경우에도 기록 메커니즘이 엔티티를 표시해야 합니다.\n\n      참고: 애플리케이션은 만료 헤더의 잘못된 구현이나 잘못된 정보에 대해 관용을 베풀어 주는 것이 좋습니다. 0 값이나 잘못된 날짜 형식은 \"즉시 만료됨\"과 동등한 것으로 간주해야 합니다. 이러한 값은 HTTP/1.0에서 합법적이지 않지만 항상 견고하게 구현하는 것이 바람직합니다.\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n10.8 From\n\n   보낸 사람 요청 헤더 필드에는 요청하는 사용자 에이전트를 제어하는 사람의 인터넷 이메일 주소가 포함되어야 합니다. 이 주소는 RFC 822 [7]의 사서함에 정의된 대로 기계가 사용할 수 있어야 합니다(RFC 1123 [6]에 의해 업데이트됨):\n\n       보낸 사람 = \"보낸 사람\" \":\" 사서함\n\n   예를 들면 다음과 같습니다:\n\n       보낸 사람: webmaster@w3.org\n\n   이 헤더 필드는 로깅 목적과 유효하지 않거나 원치 않는 요청의 출처를 식별하기 위한 수단으로 사용될 수 있습니다. 안전하지 않은 형태의 액세스 보호 수단으로 사용해서는 안 됩니다. 이 필드의 해석은 요청이 수행된 방법에 대한 책임을 수락하는 사람을 대신하여 요청이 수행되고 있다는 것입니다. 특히 로봇 에이전트는 이 헤더를 포함해야 수신 측에서 문제가 발생할 경우 로봇을 실행하는 책임자에게 연락할 수 있습니다.\n\n   이 필드의 인터넷 이메일 주소는 요청을 발행한 인터넷 호스트와 다를 수 있습니다. 예를 들어 요청이 프록시를 통해 전달되는 경우 원래 발급자의 주소를 사용해야 합니다.\n\n      참고: 사용자의 개인정보 보호 또는 사이트의 보안 정책과 충돌할 수 있으므로 클라이언트는 사용자의 승인 없이 발신자 헤더 필드를 전송해서는 안 됩니다. 사용자가 요청 전에 언제든지 이 필드의 값을 비활성화, 활성화 및 수정할 수 있도록 하는 것이 좋습니다.\n\n10.9 수정된 이후\n\n   If-Modified-Since 요청 헤더 필드는 GET 메서드와 함께 조건부로 사용되며, 이 필드에 지정된 시간 이후 요청된 리소스가 수정되지 않은 경우 서버에서 리소스 사본이 반환되지 않고 대신 엔티티 본문 없이 304(수정되지 않음) 응답이 반환됩니다.\n\n       If-Modified-Since = \"If-Modified-Since\" \":\" HTTP-date\n\n   필드의 예는 다음과 같습니다:\n\n       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   조건부 GET 메서드는 식별된 리소스가 If-Modified-Since 헤더에 지정된 날짜 이후에 수정된 경우에만 전송하도록 요청합니다. 이를 결정하는 알고리즘에는 다음과 같은 경우가 포함됩니다:\n\n      a) 요청이 정상적으로 200(확인) 상태 이외의 다른 결과를 가져오거나 전달된 If-Modified-Since 날짜가 유효하지 않은 경우, 응답은 일반 GET과 정확히 동일합니다. 서버의 현재 시간보다 늦은 날짜는 유효하지 않습니다.\n\n      b) If-Modified-Since 날짜 이후에 리소스가 수정된 경우, 응답은 일반 GET과 정확히 동일합니다.\n\n      c) 리소스가 유효한 If-Modified-Since 날짜 이후 수정되지 않은 경우 서버는 304(수정되지 않음) 응답을 반환합니다.\n\n   이 기능의 목적은 최소한의 트랜잭션 오버헤드로 캐시된 정보를 효율적으로 업데이트할 수 있도록 하는 것입니다.\n\n10.10 마지막 수정\n\n   Last-Modified 엔티티 헤더 필드는 발신자가 리소스가 마지막으로 수정되었다고 생각하는 날짜와 시간을 나타냅니다. 이 필드의 정확한 의미는 수신자가 이 필드를 어떻게 해석해야 하는지에 따라 정의됩니다. 수신자가 마지막 수정 날짜보다 오래된 리소스 사본을 가지고 있는 경우, 해당 사본은 오래된 것으로 간주해야 합니다.\n\n       Last-Modified = \"마지막 수정\" \":\" HTTP-date\n\n   사용 예는 다음과 같습니다.\n\n       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\n\n   이 헤더 필드의 정확한 의미는 발신자의 구현과 원본 리소스의 성격에 따라 다릅니다. 파일의 경우 파일 시스템의 마지막 수정 시간일 수 있습니다. 동적으로 포함된 부분이 있는 엔티티의 경우 해당 구성 요소의 마지막 수정 시간 중 가장 최근의 시간일 수 있습니다. 데이터베이스 게이트웨이의 경우 레코드의 마지막 업데이트 타임스탬프일 수 있습니다. 가상 개체의 경우 내부 상태가 마지막으로 변경된 시간일 수 있습니다.\n\n   원본 서버는 서버의 메시지 시작 시간보다 늦은 마지막 수정 날짜를 전송해서는 안 됩니다. 이러한 경우 리소스의 마지막 수정 날짜가\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   이후에는 서버가 해당 날짜를 메시지 시작 날짜로 대체해야 합니다.\n\n10.11 위치\n\n   Location 응답 헤더 필드는 Request-URI로 식별된 리소스의 정확한 위치를 정의합니다. 3xx 응답의 경우 위치는 리소스로의 자동 리디렉션을 위해 서버가 선호하는 URL을 표시해야 합니다. 절대 URL은 하나만 허용됩니다.\n\n       위치 = \"위치\" \":\" 절대URI\n\n   예는 다음과 같습니다.\n\n       위치: http://www.w3.org/hypertext/WWW/NewLocation.html\n\n10.12 Pragma\n\n   Pragma 일반 헤더 필드는 요청/응답 체인의 모든 수신자에게 적용될 수 있는 구현별 지시어를 포함하는 데 사용됩니다. 모든 프라그마 지시어는 프로토콜 관점에서 선택적 동작을 지정하지만, 일부 시스템에서는 해당 동작이 지시어와 일치하도록 요구할 수 있습니다.\n\n       프라그마 = \"프라그마\" \":\" 1#프라그마-디렉티브\n\n       프라그마-디렉티브 = \"캐시 없음\" | 확장-프라그마 확장-프라그마 = 토큰 [ \"=\" 단어 ]입니다.\n\n   요청 메시지에 \"no-cache\" 지시어가 있으면 애플리케이션은 요청된 내용의 캐시된 복사본이 있더라도 원본 서버로 요청을 전달해야 합니다. 이를 통해 클라이언트는 자신의 요청에 대해 권한 있는 응답을 받도록 주장할 수 있습니다. 또한 클라이언트는 손상되었거나 오래된 것으로 알려진 캐시된 사본을 새로 고칠 수 있습니다.\n\n   프래그마 지시어는 요청/응답 체인의 모든 수신자에게 적용될 수 있으므로 해당 애플리케이션에 대한 중요도와 관계없이 프록시 또는 게이트웨이 애플리케이션을 통해 전달되어야 합니다. 특정 수신자에 대한 프라그마를 지정할 수는 없지만, 수신자와 관련이 없는 프라그마 지시어는 해당 수신자가 무시해야 합니다.\n\n10.13 리퍼러\n\n   Referer 요청 헤더 필드는 클라이언트가 서버의 이익을 위해 요청-URI를 얻은 리소스의 주소(URI)를 지정할 수 있도록 합니다. 이를 통해 서버는 다음 목록을 생성할 수 있습니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   관심 리소스에 대한 백링크, 로깅, 최적화된 캐싱 등을 지원합니다. 또한 유지보수를 위해 더 이상 사용되지 않거나 잘못 입력된 링크를 추적할 수 있습니다. 사용자 키보드 입력과 같이 자체 URI가 없는 소스에서 Request-URI를 가져온 경우에는 Referer 필드를 보내지 않아야 합니다.\n\n       참조자 = \"참조자\" \":\" ( 절대URI | 상대URI )\n\n   예시:\n\n       Referer: http://www.w3.org/hypertext/DataSources/Overview.html\n\n   부분 URI가 제공된 경우 요청-URI를 기준으로 해석해야 합니다. URI에는 조각이 포함되어서는 안 됩니다.\n\n      참고: 링크의 출처가 개인 정보이거나 다른 개인 정보 출처를 드러낼 수 있으므로 사용자가 리퍼러 필드를 전송할지 여부를 선택할 수 있도록 하는 것이 좋습니다. 예를 들어 브라우저 클라이언트에 공개/익명 브라우징을 위한 토글 스위치가 있어 추천인 및 발신자 정보 전송을 각각 활성화/비활성화할 수 있습니다.\n\n10.14 서버\n\n   서버 응답 헤더 필드에는 원본 서버가 요청을 처리하는 데 사용하는 소프트웨어에 대한 정보가 포함됩니다. 이 필드에는 여러 개의 제품 토큰(섹션 3.7)과 서버 및 중요한 하위 제품을 식별하는 주석이 포함될 수 있습니다. 관례에 따라 제품 토큰은 애플리케이션을 식별하는 데 중요한 순서대로 나열됩니다.\n\n       서버 = \"서버\" \":\" 1*( 제품 | 댓글 )\n\n   예시:\n\n       Server: CERN/3.0 libwww/2.17\n\n   응답이 프록시를 통해 전달되는 경우 프록시 애플리케이션은 제품 목록에 해당 데이터를 추가해서는 안 됩니다.\n\n      참고: 서버의 특정 소프트웨어 버전을 공개하면 서버 컴퓨터가 보안 취약점이 있는 것으로 알려진 소프트웨어에 대한 공격에 더 취약해질 수 있습니다. 서버 구현자는 이 필드를 구성 가능한 옵션으로 설정하는 것이 좋습니다.\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n      참고: 일부 기존 서버는 서버 필드 내의 제품 토큰 구문으로 제한하지 못합니다.\n\n10.15 사용자-에이전트\n\n   사용자 에이전트 요청 헤더 필드에는 요청을 시작한 사용자 에이전트에 대한 정보가 포함됩니다. 이는 통계 목적, 프로토콜 위반 추적, 특정 사용자 에이전트 제한을 피하기 위한 맞춤형 응답을 위한 사용자 에이전트 자동 인식을 위한 것입니다. 필수는 아니지만 사용자 에이전트는 요청에 이 필드를 포함해야 합니다. 이 필드에는 여러 개의 제품 토큰(섹션 3.7)과 상담원 및 사용자 에이전트의 중요한 부분을 구성하는 하위 제품을 식별하는 댓글이 포함될 수 있습니다. 관례에 따라 제품 토큰은 애플리케이션을 식별하는 데 중요한 순서대로 나열됩니다.\n\n       사용자 에이전트 = \"사용자 에이전트\" \":\" 1*( 제품 | 댓글 )\n\n   예시:\n\n       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n\n       참고: 현재 일부 프록시 애플리케이션은 사용자-에이전트 필드의 목록에 제품 정보를 추가합니다. 이러한 필드의 기계 해석을 모호하게 만들 수 있으므로 권장하지 않습니다.\n\n       참고: 일부 기존 클라이언트는 사용자-에이전트 필드 내의 제품 토큰 구문으로 제한하지 못합니다.\n\n10.16 WWW-Authenticate\n\n   WWW-Authenticate 응답 헤더 필드는 401(권한이 없는) 응답 메시지에 포함되어야 합니다. 필드 값은 요청-URI에 적용되는 인증 체계 및 매개 변수를 나타내는 하나 이상의 챌린지로 구성됩니다.\n\n       WWW-Authenticate = \"WWW-Authenticate\" \":\" 1#챌린지\n\n   HTTP 액세스 인증 프로세스는 섹션 11에 설명되어 있습니다.   챌린지 내용에 쉼표로 구분된 인증 매개변수 목록이 포함될 수 있으므로 사용자 에이전트는 두 개 이상의 챌린지가 포함되거나 두 개 이상의 WWW-Authenticate 헤더 필드가 제공되는 경우 WWW-Authenticate 필드 값을 파싱할 때 특별한 주의를 기울여야 합니다.\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n11.  액세스 인증\n\n   HTTP는 서버가 클라이언트 요청에 도전하고 클라이언트가 인증 정보를 제공하는 데 사용할 수 있는 간단한 챌린지-응답 인증 메커니즘을 제공합니다. 이 메커니즘은 대소문자를 구분하지 않는 확장 가능한 토큰을 사용하여 인증 체계를 식별한 다음, 해당 체계를 통해 인증을 수행하는 데 필요한 매개변수를 쉼표로 구분된 속성-값 쌍 목록으로 전달합니다.\n\n       인증 체계 = 토큰\n\n       auth-param = 토큰 \"=\" 따옴표로 묶은 문자열\n\n   401(권한 없음) 응답 메시지는 원본 서버가 사용자 에이전트의 권한 부여에 이의를 제기하는 데 사용됩니다. 이 응답에는 요청된 리소스에 적용할 수 있는 챌린지가 하나 이상 포함된 WWW-Authenticate 헤더 필드가 포함되어야 합니다.\n\n       챌린지 = 인증 체계 1*SP 영역 *( \",\" auth-param )\n\n       영역 = \"영역\" \"=\" 영역-값 영역-값 = 따옴표로 묶은 문자열\n\n   영역 속성(대소문자를 구분하지 않음)은 챌린지를 발행하는 모든 인증 체계에 필요합니다. 영역 값(대소문자 구분)은 액세스하는 서버의 표준 루트 URL과 함께 보호 공간을 정의합니다. 이러한 영역을 사용하면 서버의 보호된 리소스를 각각 고유한 인증 체계 및/또는 권한 부여 데이터베이스가 있는 일련의 보호 공간으로 분할할 수 있습니다. 영역 값은 일반적으로 원본 서버에서 할당하는 문자열로, 인증 체계와 관련된 추가 의미를 가질 수 있습니다.\n\n   서버에서 자신을 인증하려는 사용자 에이전트는 일반적으로 401 응답을 받은 후(반드시 그렇지는 않지만) 요청에 Authorization 헤더 필드를 포함하여 인증할 수 있습니다. 권한 부여 필드 값은 요청되는 리소스의 영역에 대한 사용자 에이전트의 인증 정보가 포함된 자격 증명으로 구성됩니다.\n\n       자격 증명 = 기본 자격 증명 | ( 인증 체계 #인증 매개 변수 )\n\n   사용자 에이전트가 자격 증명을 자동으로 적용할 수 있는 도메인은 보호 영역에 따라 결정됩니다. 이전 요청이 승인된 경우 다음과 같이 정해진 기간 동안 해당 보호 공간 내의 다른 모든 요청에 동일한 자격 증명을 재사용할 수 있습니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   인증 체계, 매개변수 및/또는 사용자 기본 설정에 따라 달라질 수 있습니다.   인증 체계에서 달리 정의하지 않는 한, 단일 보호 공간은 해당 서버의 범위를 벗어나 확장할 수 없습니다.\n\n   서버가 요청과 함께 전송된 자격 증명을 수락하지 않으려는 경우 403(금지됨) 응답을 반환해야 합니다.\n\n   HTTP 프로토콜은 애플리케이션을 이러한 단순한 챌린지-응답 메커니즘으로만 액세스 인증을 제한하지 않습니다. 전송 수준에서의 암호화 또는 메시지 캡슐화를 통한 암호화, 인증 정보를 지정하는 추가 헤더 필드와 같은 추가 메커니즘을 사용할 수 있습니다. 그러나 이러한 추가 메커니즘은 이 규격에 정의되어 있지 않습니다.\n\n   프록시는 사용자 에이전트 인증과 관련하여 완전히 투명해야 합니다. 즉, 프록시는 WWW-Authenticate 및 Authorization 헤더를 그대로 전달해야 하며 Authorization이 포함된 요청에 대한 응답을 캐시해서는 안 됩니다. HTTP/1.0은 프록시를 통해 클라이언트를 인증할 수 있는 수단을 제공하지 않습니다.\n\n11.1 기본 인증 체계\n\n   \"기본\" 인증 체계는 사용자 에이전트가 각 영역에 대해 사용자 ID와 비밀번호로 자신을 인증해야 하는 모델을 기반으로 합니다. 영역 값은 해당 서버의 다른 영역과 동일성을 확인하기 위해서만 비교할 수 있는 불투명한 문자열로 간주해야 합니다.   서버는 요청-URI의 보호 공간에 대한 사용자 ID와 비밀번호의 유효성을 검사할 수 있는 경우에만 요청을 승인합니다.   선택적 인증 매개변수는 없습니다.\n\n   보호 공간 내에서 무단 URI 요청을 수신하면 서버는 다음과 같은 챌린지로 응답해야 합니다:\n\n       WWW-Authenticate: 기본 영역=\"WallyWorld\"\n\n   여기서 \"WallyWorld\"는 요청-URI의 보호 공간을 식별하기 위해 서버에서 할당하는 문자열입니다.\n\n   인증을 받기 위해 클라이언트는 자격증명에서 사용자 ID와 비밀번호를 하나의 콜론(\":\") 문자로 구분하여 Base64[5]로 인코딩된 문자열 내에 전송합니다.\n\n       기본 자격 증명 = \"기본\" SP 기본 쿠키\n\n       basic-cookie = 76자/줄로 제한되지 않는 사용자 아이디-비밀번호의 base64 [5] 인코딩;\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n       userid-password = [ 토큰 ] \":\" *TEXT\n\n   사용자 에이전트가 사용자 ID \"알라딘\"과 비밀번호 \"참깨\"를 보내려면 다음 헤더 필드를 사용해야 합니다:\n\n       Authorization: 기본 QWxhZGRpbjpvcGVuIHNlc2FtZQ====\n\n   기본 인증 체계는 HTTP 서버의 리소스에 대한 무단 액세스를 필터링하는 비보안 방식입니다. 이는 클라이언트와 서버 간의 연결이 신뢰할 수 있는 통신사로 간주될 수 있다는 가정을 기반으로 합니다. 개방형 네트워크에서는 일반적으로 그렇지 않으므로 기본 인증 체계를 적절히 사용해야 합니다. 그럼에도 불구하고 클라이언트는 이 체계를 사용하는 서버와 통신하기 위해 이 체계를 구현해야 합니다.\n\n12.  보안 고려 사항\n\n   이 섹션은 애플리케이션 개발자, 정보 제공자, 사용자에게 이 문서에서 설명하는 HTTP/1.0의 보안 제한 사항을 알리기 위한 것입니다. 이 논의에는 보안 위험을 줄이기 위한 몇 가지 제안이 포함되어 있지만, 드러난 문제에 대한 확실한 해결책은 포함되어 있지 않습니다.\n\n12.1 클라이언트 인증\n\n   섹션 11.1에서 언급했듯이 기본 인증 체계는 안전한 사용자 인증 방법이 아니며, 통신사로 사용되는 물리적 네트워크를 통해 엔티티-바디가 평문으로 전송되는 것을 방지하지도 않습니다. HTTP/1.0은 보안을 강화하기 위해 추가 인증 체계 및 암호화 메커니즘을 사용하는 것을 막지 않습니다.\n\n12.2 안전한 방법\n\n   클라이언트 소프트웨어 작성자는 소프트웨어가 인터넷을 통한 상호작용에서 사용자를 대표한다는 점을 인식하고 사용자가 자신 또는 타인에게 예기치 않은 영향을 미칠 수 있는 모든 행동을 인지할 수 있도록 주의를 기울여야 합니다.\n\n   특히 GET 및 HEAD 메서드는 검색 이외의 행동을 취하는 데 의미를 두어서는 안 된다는 관례가 확립되어 있습니다. 이러한 메서드는 \"안전한\" 것으로 간주되어야 합니다. 이를 통해 사용자 에이전트는 POST와 같은 다른 메서드를 특별한 방식으로 표시하여 사용자가 안전하지 않을 수 있는 작업이 요청되고 있다는 사실을 알 수 있도록 할 수 있습니다.\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   당연히 서버가 GET 요청을 수행한 결과 부작용을 생성하지 않는다고 보장할 수는 없으며, 실제로 일부 동적 리소스는 이를 기능으로 간주합니다. 여기서 중요한 차이점은 사용자가 부작용을 요청한 것이 아니므로 부작용에 대한 책임을 물을 수 없다는 것입니다.\n\n12.3 서버 로그 정보 남용\n\n   서버는 사용자의 읽기 패턴이나 관심 주제를 식별할 수 있는 사용자의 요청에 대한 개인 데이터를 저장할 수 있는 위치에 있습니다. 이 정보는 본질적으로 기밀 정보이며 특정 국가에서는 법에 따라 취급이 제한될 수 있습니다. HTTP 프로토콜을 사용하여 데이터를 제공하는 사람은 게시된 결과에서 식별 가능한 개인의 허가 없이 해당 자료가 배포되지 않도록 할 책임이 있습니다.\n\n12.4 민감한 정보의 전송\n\n   일반적인 데이터 전송 프로토콜과 마찬가지로 HTTP는 전송되는 데이터의 내용을 규제할 수 없으며, 특정 요청의 맥락 내에서 특정 정보의 민감도를 결정하는 선험적인 방법도 없습니다. 따라서 애플리케이션은 해당 정보 제공자에게 이 정보에 대한 통제권을 최대한 많이 제공해야 합니다. 이 맥락에서 세 가지 헤더 필드는 특별히 언급할 가치가 있습니다: 서버, 리퍼러, 발신자.\n\n   서버의 특정 소프트웨어 버전을 공개하면 서버 컴퓨터가 보안 취약점이 있는 것으로 알려진 소프트웨어에 대한 공격에 더 취약해질 수 있습니다. 구현자는 서버 헤더 필드를 구성 가능한 옵션으로 만들어야 합니다.\n\n   리퍼러 필드를 사용하면 읽기 패턴을 연구하고 역방향 링크를 그릴 수 있습니다. 매우 유용할 수 있지만 사용자 세부 정보가 리퍼러에 포함된 정보와 분리되지 않으면 이 기능이 남용될 수 있습니다. 개인 정보가 제거된 경우에도 참조인 필드에 공개가 부적절한 비공개 문서의 URI가 표시될 수 있습니다.\n\n   보낸 사람 필드에서 전송되는 정보는 사용자의 개인정보 보호 또는 사이트의 보안 정책과 충돌할 수 있으므로 사용자가 이 필드의 내용을 비활성화, 활성화 및 수정할 수 없는 상태에서 전송되어서는 안 됩니다. 사용자는 사용자 기본 설정 또는 애플리케이션 기본 구성 내에서 이 필드의 내용을 설정할 수 있어야 합니다.\n\n   필수 사항은 아니지만 사용자가 발신자 및 참조인 정보 전송을 활성화 또는 비활성화할 수 있는 편리한 토글 인터페이스를 제공할 것을 권장합니다.\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n12.5 파일 및 경로 이름에 기반한 공격\n\n   HTTP 오리진 서버의 구현은 HTTP 요청이 반환하는 문서가 서버 관리자가 의도한 문서로만 제한되도록 주의해야 합니다. HTTP 서버가 HTTP URI를 파일 시스템 호출로 직접 변환하는 경우, 서버는 HTTP 클라이언트에 전달할 의도가 없는 파일을 제공하지 않도록 각별히 주의해야 합니다. 예를 들어 Unix, Microsoft Windows 및 기타 운영 체제는 경로 구성 요소로 '...'를 사용하여 현재 디렉터리 수준보다 상위의 디렉터리 수준을 나타냅니다. 이러한 시스템에서 HTTP 서버를 통해 액세스하도록 의도된 리소스 이외의 리소스에 대한 액세스를 허용하는 경우 HTTP 서버는 요청-URI에서 이러한 구성을 허용하지 않아야 합니다. 마찬가지로 접근 제어 파일, 구성 파일, 스크립트 코드 등 서버 내부에서만 참조하도록 의도된 파일은 민감한 정보를 포함할 수 있으므로 부적절한 검색으로부터 보호해야 합니다. 경험에 따르면 이러한 HTTP 서버 구현의 사소한 버그가 보안 위험으로 바뀐 경우가 많습니다.\n\n13.  감사\n\n   이 명세는 데이비드 H. 크로커가 RFC 822 [7]에 정의한 증강 BNF와 일반 구성을 많이 사용합니다. 마찬가지로, 이 명세서는 나다니엘 보렌스타인과 네드 프리드가 MIME에 대해 제공한 많은 정의를 재사용합니다[5]. 이 사양에 포함됨으로써 HTTP/1.0과 인터넷 메일 메시지 형식 간의 관계에 대한 과거의 혼란을 줄이는 데 도움이 되기를 바랍니다.\n\n   HTTP 프로토콜은 지난 4년 동안 상당히 발전해 왔습니다.   이는 대규모의 활발한 개발자 커뮤니티, 즉 www-talk 메일링 리스트에 참여한 많은 사람들로부터 혜택을 받았으며, 이러한 커뮤니티는 HTTP와 월드와이드웹 전반의 성공에 가장 큰 책임이 있는 커뮤니티입니다. 마크 안드레센, 로버트 카일리아우, 다니엘 코놀리, 밥 데니, 장 프랑소와 그로프, 필립 M. 할램 베이커, 하콘 W. 라이, 아리 루오토넨, 롭 맥쿨, 루 몬툴리, 데이브 래겟, 토니 샌더스, 마크 반헤닝언은 이 사양의 초기 버전 프로토콜을 정의한 공로로 특별히 인정받아야 마땅합니다.\n\n   폴 호프만은 본 문서와 부록 C 및 D의 정보 제공 현황에 관한 섹션을 기고했습니다.\n\n\n\n\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   이 문서는 HTTP-WG에 참여한 모든 분들의 의견으로부터 많은 도움을 받았습니다. 이미 언급된 분들 외에도 다음과 같은 분들이 이 사양에 기여해 주셨습니다:\n\n       게리 아담스 해럴드 트베이트 알베스트란트 키스 볼 브라이언 벨렌도르프 폴 버처드 마우리치오 고도뇨 마이크 카울리쇼 로만 치보라 마이클 A. 돌란 존 프랭크스 짐 게티스 마크 헤드룬드 코엔 홀트만 알렉스 호프만 밥 저니건 쉘 카판 마르틴 코스터 데이브 크리톨 다니엘 라리베르테 폴 리치 알버트 룬데 존 C.. 래리 마신터 미트라 제프리 모굴 개빈 니콜 빌 페리 제프리 페리 오웬 리스 루이지 리조 데이비드 로빈슨 마크 살로몬 리치 살츠 짐 시드먼 척 쇼튼 에릭 W. 싱크 사이먼 E. 스페로 로버트 S. 타우 프랑수아 예르고 메리 엘렌 주르코 장 필립 마틴-플라틴\n\n14. 참고 문헌\n\n   [1] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey, D., B. Alberti, \"인터넷 고퍼 프로토콜: 분산 문서 검색 및 검색 프로토콜\", RFC 1436, 미네소타 대학교, 1993년 3월.\n\n   [2] Berners-Lee, T., \"WWW의 범용 자원 식별자: 월드와이드웹에서 사용되는 네트워크 상의 객체 이름과 주소 표현을 위한 통합 구문\", RFC 1630, CERN, June 1994.\n\n   [3] Berners-Lee, T., 및 D. Connolly, \"Hypertext Markup Language - 2.0\", RFC 1866, MIT/W3C, 1995년 11월.\n\n   [4] Berners-Lee, T., Masinter, L. 및 M. McCahill, \"Uniform Resource Locators (URL)\", RFC 1738, CERN, Xerox PARC, University of Minnesota, 1994년 12월.\n\n\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   [5] Borenstein, N., 및 N. Freed, \"MIME(Multipurpose Internet Mail Extensions) 파트 1: 인터넷 메시지 본문의 형식을 지정하고 설명하는 메커니즘\", RFC 1521, Bellcore, Innosoft, 1993년 9월.\n\n   [6] Braden, R., \"인터넷 호스트에 대한 요구 사항 - 응용 및 지원\", STD 3, RFC 1123, IETF, 1989년 10월.\n\n   [7] Crocker, D., \"ARPA 인터넷 문자 메시지 형식에 대한 표준\", STD 11, RFC 822, UDEL, 1982년 8월.\n\n   [8] F. Davis, B. Kahle, H. Morris, J. Salem, T. Shen, R. Wang, J. Sui, M. Grinbaum. \"WAIS 인터페이스 프로토콜 프로토타입 기능 사양.\" (v1.5), Thinking Machines Corporation, 1990년 4월.\n\n   [9] Fielding, R., \"Relative Uniform Resource Locators\", RFC 1808, UC Irvine, June 1995.\n\n   [10] Horton, M., and R. Adams, \"USENET 메시지 교환 표준\", RFC 1036 (Obsoletes RFC 850), AT&amp;T Bell Laboratories, Center for Seismic Studies, 1987년 12월.\n\n   [11] 칸토르, B., 및 랩슬리, P., \"네트워크 뉴스 전송 프로토콜:        스트림 기반 뉴스 전송을 위한 제안된 표준\", RFC 977, UC 샌디에이고, UC 버클리, 1986년 2월.\n\n   [12] Postel, J., \"단순 메일 전송 프로토콜.\" STD 10, RFC 821, USC/ISI, 1982년 8월.\n\n   [13] Postel, J., \"미디어 유형 등록 절차.\" RFC 1590, USC/ISI, March 1994.\n\n   [14] Postel, J., 및 J. Reynolds, \"File Transfer Protocol (FTP)\", STD 9, RFC 959, USC/ISI, 1985년 10월.\n\n   [15] 레이놀즈, J., 및 J. 포스텔, \"할당 번호\", STD 2, RFC 1700, USC/ISI, 1994년 10월.\n\n   [16] Sollins, K., 및 L. Masinter, \"Uniform Resource Name의 기능적 요구사항\", RFC 1737, MIT/LCS, Xerox Corporation, 1994년 12월.\n\n   [17] US-ASCII. 코드화된 문자 집합 - 정보 교환을 위한 7비트 미국 표준 코드. 표준 ANSI X3.4-1986, ANSI, 1986.\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   [18] ISO-8859. 국제 표준 -- 정보 처리 -- 8비트 단일 바이트 코딩 그래픽 문자 집합 -- 파트 1: 라틴 알파벳 1, ISO 8859-1:1987.        파트 2: 라틴 알파벳 2번, ISO 8859-2, 1987.        파트 3: 라틴 알파벳 3번, ISO 8859-3, 1988.        파트 4: 라틴 알파벳 4번, ISO 8859-4, 1988.        파트 5: 라틴/키릴 문자, ISO 8859-5, 1988.        파트 6: 라틴/아랍 알파벳, ISO 8859-6, 1987.        파트 7: 라틴/그리스 알파벳, ISO 8859-7, 1987.        파트 8: 라틴/히브리 알파벳, ISO 8859-8, 1988.        파트 9: 라틴 알파벳 5번, ISO 8859-9, 1990.\n\n15.  저자 주소\n\n   팀 버너스-리 W3 컨소시엄 MIT 컴퓨터 과학 연구소 545 Technology Square Cambridge, MA 02139, USA.\n\n   팩스: +1 (617) 258 8682 이메일: timbl@w3.org\n\n   로이 필딩 정보 및 컴퓨터 과학과 캘리포니아 대학교 어바인, 캘리포니아 92717-3425, 미국\n\n   팩스: +1 (714) 824-4056 이메일: fielding@ics.uci.edu\n\n   헨릭 프리스티크 닐슨 W3 컨소시엄 MIT 컴퓨터 과학 연구소 545 Technology Square Cambridge, MA 02139, U.S.A.\n\n   팩스: +1 (617) 258 8682 이메일: frystyk@w3.org\n\n\n\n\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n부록\n\n   이 부록은 정보 제공 목적으로만 제공되며 HTTP/1.0 사양의 일부를 구성하지 않습니다.\n\nA.  인터넷 미디어 유형 메시지/http\n\n   이 문서는 HTTP/1.0 프로토콜을 정의하는 것 외에도 인터넷 미디어 유형 \"message/http\"에 대한 사양으로 사용됩니다. 다음은 IANA[13]에 등록할 내용입니다.\n\n       미디어 유형 이름: 메시지\n\n       미디어 하위 유형 이름: http\n\n       필수 매개변수: 없음\n\n       선택적 매개변수: 버전, 메시지 유형\n\n              버전: 동봉된 메시지의 HTTP 버전 번호(예: \"1.0\"). 없는 경우 본문의 첫 줄에서 버전을 확인할 수 있습니다.\n\n              msgtype: 메시지 유형 - \"요청\" 또는 \"응답\". 없는 경우 본문의 첫 번째 줄에서 유형을 확인할 수 있습니다.\n\n       인코딩 고려 사항: \"7비트\", \"8비트\" 또는 \"바이너리\"만 허용됩니다.\n\n       보안 고려 사항: 없음\n\nB.  내성 애플리케이션\n\n   이 문서는 HTTP/1.0 메시지 생성을 위한 요구 사항을 명시하고 있지만, 모든 애플리케이션이 이를 올바르게 구현하는 것은 아닙니다. 따라서 운영 중인 애플리케이션은 이러한 편차를 명확하게 해석할 수 있는 경우 편차를 허용할 것을 권장합니다.\n\n   클라이언트는 상태 줄을 구문 분석할 때 관대해야 하고 서버는 요청 줄을 구문 분석할 때 관대해야 합니다. 특히, 필드 사이에 SP 또는 HT 문자가 하나만 필요하더라도 얼마든지 허용해야 합니다.\n\n   HTTP 헤더 필드의 줄 종결자는 시퀀스 CRLF입니다.   그러나 애플리케이션은 이러한 헤더를 파싱할 때 단일 LF를 줄 종결자로 인식하고 선행 CR은 무시하는 것이 좋습니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\nC.  MIME과의 관계\n\n   HTTP/1.0은 인터넷 메일(RFC 822 [7])과 다목적 인터넷 메일 확장(MIME [5])에 정의된 많은 구성을 사용하여 엔티티가 개방적이고 다양한 표현과 확장 가능한 메커니즘으로 전송될 수 있도록 합니다. 그러나 RFC 1521은 메일에 대해 설명하며, HTTP에는 RFC 1521에서 설명하는 것과는 다른 몇 가지 기능이 있습니다. 이러한 차이점은 이진 연결에 대한 성능을 최적화하고, 새로운 미디어 유형을 보다 자유롭게 사용할 수 있도록 하며, 날짜 비교를 보다 쉽게 하고, 일부 초기 HTTP 서버와 클라이언트의 관행을 인정하기 위해 신중하게 선택되었습니다.\n\n   이 글을 쓰는 시점에 RFC 1521이 개정될 것으로 예상됩니다. 개정안에는 HTTP/1.0에는 있지만 RFC 1521에는 없는 일부 관행이 포함될 수 있습니다.\n\n   이 부록에서는 HTTP가 RFC 1521과 다른 특정 영역에 대해 설명합니다. 엄격한 MIME 환경을 사용하는 프록시와 게이트웨이는 이러한 차이점을 인지하고 필요한 경우 적절한 변환을 제공해야 합니다. MIME 환경의 프록시 및 게이트웨이에서 HTTP로 변환하는 경우에도 일부 변환이 필요할 수 있으므로 차이점을 알고 있어야 합니다.\n\nC.1 표준 형식으로의 변환\n\n   RFC 1521에서는 인터넷 메일 엔티티를 전송하기 전에 RFC 1521 [5]의 부록 G에 설명된 대로 표준 형식으로 변환할 것을 요구합니다. 이 문서의 3.6.1절에서는 HTTP를 통해 전송할 때 '텍스트' 미디어 유형의 하위 유형에 허용되는 형식에 대해 설명합니다.\n\n   RFC 1521에서는 콘텐츠 유형이 \"텍스트\"인 콘텐츠는 줄 바꿈을 CRLF로 표시해야 하며, 줄 바꿈 시퀀스 외부에서 CR 또는 LF를 사용하는 것을 금지하고 있습니다. HTTP는 HTTP를 통해 메시지가 전송될 때 텍스트 콘텐츠 내에서 줄 바꿈을 표시하기 위해 CRLF, 베어 CR 및 베어 LF를 허용합니다.\n\n   가능한 경우, HTTP에서 엄격한 RFC 1521 환경으로 전송하는 프록시 또는 게이트웨이는 이 문서의 3.6.1절에 설명된 텍스트 미디어 유형 내의 모든 줄 바꿈을 RFC 1521 표준 형식의 CRLF로 변환해야 합니다. 그러나 콘텐츠 인코딩의 존재와 일부 멀티바이트 문자 집합의 경우처럼 HTTP가 CR 및 LF를 표현하기 위해 옥텟 13과 10을 사용하지 않는 일부 문자 집합의 사용을 허용한다는 사실로 인해 이 작업이 복잡해질 수 있다는 점에 유의하세요.\n\n\n\n\n\n버너스 리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\nC.2 날짜 형식의 변환\n\n   HTTP/1.0은 날짜 비교 프로세스를 단순화하기 위해 제한된 날짜 형식 집합(섹션 3.3)을 사용합니다. 다른 프로토콜의 프록시 및 게이트웨이는 메시지에 있는 날짜 헤더 필드가 HTTP/1.0 형식 중 하나를 준수하는지 확인하고 필요한 경우 날짜를 다시 작성해야 합니다.\n\nC.3 콘텐츠 인코딩 도입\n\n   RFC 1521에는 HTTP/1.0의 Content-Encoding 헤더 필드에 해당하는 개념이 포함되어 있지 않습니다. 이는 미디어 타입에 대한 수정자 역할을 하므로, HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지를 전달하기 전에 Content-Type 헤더 필드 값을 변경하거나 Entity-Body를 디코딩해야 합니다. (인터넷 메일에 Content-Type을 실험적으로 적용한 일부 애플리케이션에서는 \";conversions=&lt;content-coding&lt;\"의 미디어 유형 매개 변수를 사용하여 Content-Encoding과 동등한 기능을 수행했습니다. 그러나 이 매개 변수는 RFC 1521의 일부가 아닙니다.)\n\nC.4 콘텐츠 전송 인코딩 없음\n\n   HTTP는 RFC 1521의 콘텐츠-트랜스퍼-인코딩(CTE) 필드를 사용하지 않습니다. 프록시와 게이트웨이는 MIME 호환 프로토콜에서 HTTP로 응답 메시지를 전달하기 전에 비식별 CTE(\"quoted-printable\" 또는 \"base64\") 인코딩을 제거한 후 HTTP 클라이언트에 전달해야 합니다.\n\n   HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 해당 프로토콜에서 안전한 전송을 위해 메시지가 올바른 형식과 인코딩으로 되어 있는지 확인할 책임이 있으며, 여기서 '안전한 전송'은 사용 중인 프로토콜의 제한에 따라 정의됩니다.   이러한 프록시 또는 게이트웨이는 대상 프로토콜을 통한 안전한 전송 가능성을 높일 수 있는 경우 적절한 콘텐츠 전송 인코딩으로 데이터에 레이블을 지정해야 합니다.\n\nC.5 여러 부분으로 구성된 본문 부분의 HTTP 헤더 필드\n\n   RFC 1521에서 멀티파트 본문 부분의 대부분의 헤더 필드는 일반적으로 필드 이름이 \"Content-\"로 시작하지 않는 한 무시됩니다. HTTP/1.0에서 멀티파트 본문-파트는 해당 파트의 의미에 중요한 모든 HTTP 헤더 필드를 포함할 수 있습니다.\n\nD.  추가 기능\n\n   이 부록은 일부 기존 HTTP 구현에서 사용되지만 대부분의 HTTP/1.0 애플리케이션에서 일관되고 올바르게 사용되지는 않는 프로토콜 요소를 문서화합니다. 구현자는 이러한 기능을 알고 있어야 하지만, 이러한 기능의 존재 또는 상호 운용성에 의존해서는 안 됩니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   와 함께, 다른 HTTP/1.0 애플리케이션.\n\nD.1 추가 요청 방법\n\nD.1.1 PUT\n\n   PUT 메서드는 제공된 Request-URI에 포함된 엔티티를 저장하도록 요청합니다. 요청 URL이 이미 존재하는 리소스를 가리키는 경우, 동봉된 엔티티는 원본 서버에 있는 리소스의 수정된 버전으로 간주해야 합니다. 요청-URI가 기존 리소스를 가리키지 않고 요청하는 사용자 에이전트가 해당 URI를 새 리소스로 정의할 수 있는 경우 원본 서버는 해당 URI로 리소스를 만들 수 있습니다.\n\n   POST 요청과 PUT 요청의 근본적인 차이점은 Request-URI의 다른 의미에 반영되어 있습니다. POST 요청의 URI는 처리할 데이터로 묶인 엔티티를 처리할 리소스를 식별합니다. 해당 리소스는 데이터를 수락하는 프로세스, 다른 프로토콜의 게이트웨이 또는 주석을 수락하는 별도의 엔티티일 수 있습니다. 이와 대조적으로 PUT 요청의 URI는 요청에 포함된 엔티티를 식별합니다. 사용자 에이전트는 URI의 의도를 알고 있으며 서버는 요청을 다른 리소스에 적용해서는 안 됩니다.\n\nD.1.2 DELETE\n\n   DELETE 메서드는 원본 서버가 요청-URI로 식별된 리소스를 삭제하도록 요청합니다.\n\nD.1.3 LINK\n\n   LINK 메서드는 요청-URI로 식별된 기존 리소스와 다른 기존 리소스 간에 하나 이상의 링크 관계를 설정합니다.\n\nD.1.4 UNLINK\n\n   UNLINK 메서드는 요청-URI로 식별된 기존 리소스에서 하나 이상의 링크 관계를 제거합니다.\n\nD.2 추가 헤더 필드 정의\n\nD.2.1 Accept\n\n   Accept 요청 헤더 필드는 요청에 대한 응답으로 허용되는 미디어 범위 목록을 표시하는 데 사용할 수 있습니다. 별표 \"*\" 문자는 미디어 유형을 범위로 그룹화하는 데 사용되며, \"*/*\"는 모든 미디어 유형을 나타내고 \"type/*\"는 모든 하위 유형을 나타냅니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\n   를 반환합니다. 클라이언트가 제공한 범위 집합은 요청의 컨텍스트에 따라 허용되는 유형을 나타내야 합니다.\n\nD.2.2 Accept-Charset\n\n   Accept-Charset 요청 헤더 필드는 기본 US-ASCII 및 ISO-8859-1 이외의 기본 문자 집합 목록을 표시하는 데 사용할 수 있습니다. 이 필드를 사용하면 보다 포괄적이거나 특수 목적의 문자 집합을 이해할 수 있는 클라이언트가 해당 문자 집합으로 문서를 표현할 수 있는 서버에 해당 기능을 알릴 수 있습니다.\n\nD.2.3 인코딩 허용\n\n   Accept-Encoding 요청 헤더 필드는 Accept와 유사하지만 응답에 허용되는 콘텐츠 인코딩 값을 제한합니다.\n\nD.2.4 Accept-Language\n\n   Accept-Language 요청 헤더 필드는 Accept와 유사하지만 요청에 대한 응답으로 선호되는 자연어 집합을 제한합니다.\n\nD.2.5 Content-Language\n\n   Content-Language 엔티티 헤더 필드는 동봉된 엔티티에 대한 의도된 대상의 자연어를 설명합니다. 이 언어는 엔티티 내에서 사용되는 모든 언어와 동일하지 않을 수 있습니다.\n\nD.2.6 링크\n\n   링크 엔티티 헤더 필드는 엔티티와 다른 리소스 간의 관계를 설명하는 수단을 제공합니다. 엔티티에는 여러 개의 링크 값이 포함될 수 있습니다. 메타정보 수준의 링크는 일반적으로 계층 구조 및 탐색 경로와 같은 관계를 나타냅니다.\n\nD.2.7 MIME-버전\n\n   HTTP 메시지에는 메시지를 구성하는 데 사용된 MIME 프로토콜의 버전을 나타내는 단일 MIME-Version 일반 헤더 필드가 포함될 수 있습니다. RFC 1521[5]에 정의된 대로 MIME-Version 헤더 필드를 사용하면 메시지가 MIME 규격을 준수한다는 것을 나타냅니다.   안타깝게도 일부 구형 HTTP/1.0 서버는 이 필드를 무분별하게 전송하므로 이 필드는 무시해야 합니다.\n\n\n\n버너스-리 등 정보\fRFC 1945 HTTP/1.0 1996년 5월\n\nD.2.8 재시도 후\n\n   Retry-After 응답 헤더 필드는 503(서비스를 사용할 수 없음) 응답과 함께 사용하여 요청 클라이언트가 서비스를 사용할 수 없을 것으로 예상되는 시간을 나타낼 수 있습니다. 이 필드의 값은 응답 시간 이후 HTTP 날짜 또는 정수(십진수)일 수 있습니다.\n\nD.2.9 제목\n\n   제목 엔티티 헤더 필드는 엔티티의 제목을 나타냅니다.\n\nD.2.10 URI\n\n   URI 엔티티 헤더 필드에는 요청-URI 리소스를 식별할 수 있는 유니폼 리소스 식별자(섹션 3.2)의 일부 또는 전부가 포함될 수 있습니다. 지정된 URI를 사용하여 리소스에 액세스할 수 있다는 보장은 없습니다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n버너스 리 등 정보\f"
    </textarea>
</body>
</html>